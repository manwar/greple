{"name":"Greple","tagline":"greple: grep type command with multiple keywords","body":"# NAME\r\n\r\ngreple - grep with multiple keywords\r\n\r\n# SYNOPSIS\r\n\r\n__greple__ \\[__-M___module_\\] \\[ __-options__ \\] pattern \\[ file... \\]\r\n\r\n    pattern           'positive -negative ?alternative'\r\n\r\n    -e pattern        regex pattern match across line boundary\r\n    -v pattern        regex pattern not to be matched\r\n    --le pattern      lexical expression (same as bare pattern)\r\n    --re pattern      regular expression\r\n    --fe pattern      fixed expression\r\n\r\n__OPTIONS__\r\n\r\n    -i                   ignore case\r\n    -l                   list filename only\r\n    -c                   print count of matched block only\r\n    -n                   print line number\r\n    -h                   do not display filenames\r\n    -H                   always display filenames\r\n    --inside=pattern     select matches inside of pattern\r\n    --outside=pattern    select matches outside of pattern\r\n    --include=pattern    reduce matches to the area\r\n    --exclude=pattern    reduce matches to outside of the area\r\n    --strict             strict mode for --inside/outside --block\r\n    --join               delete newline in the matched part\r\n    --joinby=string      replace newline in the matched text by string\r\n    --filestyle=style    how filename printed (once, separate, line)\r\n    --linestyle=style    how line number printed (separate, line)\r\n\r\n    --need=n             required positive match count\r\n    --allow=n            acceptable negative match count\r\n\r\n    --color=when         use terminal color (auto, always, never)\r\n    --nocolor            same as --color=never\r\n    --colormode=mode     R, G, B, C, M, Y, W, Standout, bolD, Underline\r\n    --colorful           same as --colormode 'RD GD BD CD MD YD'\r\n    --random             random color\r\n    --regioncolor        color by region\r\n\r\n    -o                   print only the matching part\r\n    -p                   paragraph mode\r\n    -A[n]                after match context\r\n    -B[n]                before match context\r\n    -C[n]                after and before match context\r\n    --all                print whole data\r\n    --block=pattern      specify the block of records\r\n    --blockend=s         specify the block end mark (Default: \"--\\n\")\r\n\r\n    -f file              file contains search pattern\r\n    -d flags             display info (f:file d:dir c:count m:misc s:stat)\r\n    --man                show manual page\r\n    --icode=name         specify file encoding\r\n    --ocode=name         specify output encoding\r\n    --if=filter          set filter command\r\n    --of=filter          output filter command\r\n    --noif               disable default input filter\r\n    --[no]pgp            decrypt and find PGP file (Default: false)\r\n    --pgppass=phrase     pgp passphrase\r\n    --readlist           get filenames from stdin\r\n    --chdir              change directory before search\r\n    --glob=glob          glob target files\r\n    --print=func         print function\r\n    --continue           continue after print function\r\n    --norc               skip reading startup file\r\n\r\n# DESCRIPTION\r\n\r\n__greple__ has almost the same function as Unix command [egrep(1)](http://man.he.net/man1/egrep) but\r\nthe search is done in the manner similar to search engine.  For\r\nexample, next command print lines those contain all of \\`foo' and \\`bar'\r\nand \\`baz'.\r\n\r\n    greple 'foo bar baz' ...\r\n\r\nEach word can be found in any order and/or any place in the string.\r\nSo this command find all of following texts.\r\n\r\n    foo bar baz\r\n    baz bar foo\r\n    the foo, bar and baz\r\n\r\nIf you want to use OR syntax, prepend question (\\`?') mark on each\r\ntoken, or use regular expression.\r\n\r\n    greple 'foo bar baz ?yabba ?dabba ?doo'\r\n    greple 'foo bar baz yabba|dabba|doo'\r\n\r\nThis command will print the line which contains all of \\`foo', \\`bar'\r\nand \\`baz' and one or more from \\`yabba', \\`dabba' or \\`doo'.\r\n\r\nNOT operator can be specified by prefixing the token by minus (\\`-')\r\nsign.  Next example will show the line which contain both \\`foo' and\r\nbar' but none of \\`yabba' or \\`dabba' or \\`doo'.  It is ok to put \\`+'\r\nmark for positive matching pattern.\r\n\r\n    greple 'foo bar -yabba -dabba -doo'\r\n    greple '+foo +bar -yabba|dabba|doo'\r\n\r\nThis can be written as this using __-e__ and __-v__ option.\r\n\r\n    greple -e foo -e bar -v yabba -v dabba -v doo\r\n    greple -e foo -e bar -v 'yabba|dabba|doo'\r\n\r\n__LINE ACROSS MATCH__\r\n\r\n__greple__ also search the pattern across the line boundaries.  This is\r\nespecially useful to handle Asian multi-byte text.  Japanese text can\r\nbe separated by newline almost any place of the text.  So the search\r\npattern may spread out on multiple lines.  As for ascii text, space\r\ncharacter in the pattern matches any kind of space including newline.\r\nUse __-e__ option to use this capability because space is taken as a\r\ntoken separator in the bare pattern.\r\n\r\n# OPTIONS\r\n\r\n__PATTERNS__\r\n\r\nIf specific option is not provided, __greple__ takes the first argument\r\nas a search pattern specified by __-le__ option.  All of these patterns\r\ncan be specified multiple times.\r\n\r\nCommand itself is written in Perl, and any kind of Perl style regular\r\nexpression can be used in patterns.\r\n\r\n- __--le__=_pattern_\r\n\r\n    Treat the string as a collection of tokens separated by spaces.  Each\r\n    token is interpreted by the first character.  Token start with \\`-'\r\n    means negative pattern, \\`?' means alternative, optional \\`+' and\r\n    anything other means positive match.\r\n\r\n    Next example print lines which contains \\`foo' and \\`bar', and one or\r\n    more of \\`yabba' and 'dabba', and none of \\`bar' and \\`doo'.\r\n\r\n        greple --le='foo bar -baz ?yabba ?dabba -doo'\r\n\r\n    Multiple \\`?' preceded tokens are treated all mixed together.  That\r\n    means \\`?A|B ?C|D' is equivalent to \\`?A|B|C|D'.  If you want to mean\r\n    \\`(A or B) and (C or D)', use AND syntax instead: \\`A|B C|D'.\r\n\r\n- __-e__ _pattern_, __--and__=_pattern_\r\n\r\n    Specify positive match token.  Next two commands are equivalent.\r\n\r\n        greple 'foo bar baz'\r\n        greple -e foo -e bar -e baz\r\n\r\n    First character is not interpreted, so next commands will search the\r\n    pattern \\`-baz'.\r\n\r\n        greple -e -baz\r\n\r\n    Space characters are treated specially by __-e__ and __-v__ options.\r\n    They are replaced by the pattern which matches any number of\r\n    white spaces including newline.  So the pattern can be expand to\r\n    multiple lines.  Next commands search the series of word \\`foo', \\`bar'\r\n    and \\`baz' even if they are separated by newlines.\r\n\r\n        greple -e 'foo bar baz'\r\n\r\n- __-v__ _pattern_, __--not__=_pattern_\r\n\r\n    Specify negative match token.  Because it does not affect to the bare\r\n    pattern argument, you can narrow down the search result like this.\r\n\r\n        greple foo pattern file\r\n        greple foo pattern file -v bar\r\n        greple foo pattern file -v bar -v baz\r\n\r\n- __--re__=_pattern_\r\n\r\n    Specify regular expression.  No special treatment for space and wide\r\n    characters.\r\n\r\n- __--fe__=_pattern_\r\n\r\n    Specify fixed string pattern, like fgrep.\r\n\r\n__GREP LIKE OPTIONS__\r\n\r\n- __-i__\r\n\r\n    Ignore case.\r\n\r\n- __-l__\r\n\r\n    List filename only.\r\n\r\n- __-c__, __--count__\r\n\r\n    Print count of matched block.\r\n\r\n- __-n__\r\n\r\n    Show line number.\r\n\r\n- __-h__, __--no-filename__\r\n\r\n    Do not display filename.\r\n\r\n- __-H__\r\n\r\n    Display filename always.\r\n\r\n- __-o__\r\n\r\n    Print matched string only.\r\n\r\n- __-A__\\[_n_\\], __--after-context__\\[=_n_\\]\r\n- __-B__\\[_n_\\], __--before-context__\\[=_n_\\]\r\n- __-C__\\[_n_\\], __--context__\\[=_n_\\]\r\n\r\n    Print _n_-blocks before/after matched string.  The value _n_ can be\r\n    omitted and the default is 2.  When used with paragraph option __-p__,\r\n    _n_ means number of paragraphs.\r\n\r\n    Actually, these options expand the area of logical operation.  It\r\n    means\r\n\r\n        grep -C1 'foo bar baz'\r\n\r\n    matches following text.\r\n\r\n        foo\r\n        bar\r\n        baz\r\n\r\n    Moreover\r\n\r\n        greple -C1 'foo baz'\r\n\r\n    also matches this text, because matching blocks around \\`foo' and \\`bar'\r\n    overlaps each other and makes single block.\r\n\r\n- __-f__ _file_, __--file__=_file_\r\n\r\n    Specify the file which contains search pattern.  When file contains\r\n    multiple lines, patterns on each lines are search in OR context.  The\r\n    line starting with sharp (#) character is ignored.\r\n\r\n- __--color__=_auto_|_always_|_never_, __--nocolor__\r\n\r\n    Use terminal color capability to emphasize the matched text.  Default\r\n    is \\`auto': effective when STDOUT is a terminal and option __-o__ is not\r\n    given, not otherwise.  Option value \\`always' and \\`never' will work as\r\n    expected.\r\n\r\n    Option __--nocolor__ is alias for __--color__=_never_.\r\n\r\n- __--colormode__=_RGBCYMKWrgbcymkwSUDF_, __--quote__=_start_,_end_\r\n\r\n    Specify color mode.  Default is RD: RED and BOLD.\r\n\r\n    COLOR is combination of single character representing uppercase\r\n    foreground color :\r\n\r\n        R  Red\r\n        G  Green\r\n        B  Blue\r\n        C  Cyan\r\n        M  Magenta\r\n        Y  Yellow\r\n        K  Black\r\n        W  White\r\n\r\n    and corresponding lowercase background color :\r\n\r\n        r, g, b, c, m, y, k, w\r\n\r\n    and other effects :\r\n\r\n        S  Standout (reverse video)\r\n        U  Underline\r\n        D  Double-struck (boldface)\r\n        F  Flash (blink)\r\n\r\n    If the mode string contains comma \\`,' character, they are used to\r\n    quote the matched string.  If you want to quote the pattern by angle\r\n    bracket, use like this.\r\n\r\n        greple --quote='<,>' pattern\r\n\r\n    Option __--quote__ is an alias for __--colormode__, but it set the\r\n    option __--color__=_always_ at the same time.\r\n\r\n    Multiple colors can be specified separating by white spaces.  Those\r\n    colors will be applied for each pattern keywords.  Next command will\r\n    show word \\`foo' in red, \\`bar' in green and \\`baz' in blue.\r\n\r\n        greple --colormode='R G B' 'foo bar baz' ...\r\n\r\n- __--colorful__\r\n\r\n    Shortcut for __--colormode__='_RD GD BD CD MD YD_'\r\n\r\n- __--filestyle__=_style_, __--fs__\r\n\r\n    Default style is _line_, and __greple__ prints filename at the\r\n    beginning of each line.  Style _once_ prints the filename only once\r\n    at the first time.  Style _separate_ prints filename in the separate\r\n    line before each line or block.\r\n\r\n- __--linestyle__=_style_, __--ls__\r\n\r\n    Default style is _line_, and __greple__ prints line numbers at the\r\n    beginning of each line.  Style _separate_ prints line number in the\r\n    separate line before each line or block.\r\n\r\n__OTHER OPTIONS__\r\n\r\n- __-p__, __--paragraph__\r\n\r\n    Print the paragraph which contains the pattern.  Each paragraph is\r\n    delimited by two or more successive newline characters by default.  Be\r\n    aware that an empty line is not paragraph delimiter if which contains\r\n    space characters.  Example:\r\n\r\n        greple -np 'setuid script' /usr/man/catl/perl.l\r\n\r\n        greple -pe '^struct sockaddr' /usr/include/sys/socket.h\r\n\r\n    It changes the unit of context specified by __-A__, __-B__, __-C__\r\n    options.\r\n\r\n- __--all__\r\n\r\n    Treat entire file contents as a single block.  This is almost\r\n    identical to following command.\r\n\r\n        greple --block='(?s).*'\r\n\r\n- __--block__=_pattern_, __--block__=_&sub_\r\n\r\n    Specify the record block to display.  Default block is a single line.\r\n\r\n    Next is almost same as __--paragraph__ option.\r\n\r\n        greple --block='(.+\\n)+'\r\n\r\n    Next command treat the data as a series of 10-line blocks.\r\n\r\n        greple -n --block='(.*\\n){1,10}'\r\n\r\n    When blocks are not continuous and there are gaps between them, the\r\n    match occurred outside blocks are ignored.\r\n\r\n    If multiple block options are supplied, overlapping blocks are merged\r\n    into single block.\r\n\r\n    Please be aware that this option is sometimes quite time consuming,\r\n    because it finds all blocks before processing.\r\n\r\n- __--blockend__=_string_\r\n\r\n    Change the end mark displayed after __-pABC__ or __--block__ options.\r\n    Default value is \"--\\\\n\".\r\n\r\n- __--inside__=_pattern_\r\n- __--outside__=_pattern_\r\n\r\n    Option __--inside__ and __--outside__ limit the text area to be matched.\r\n    For simple example, if you want to find string \\`and' not in the word\r\n    \\`command', it can be done like this.\r\n\r\n        greple --outside=command and\r\n\r\n    The block can be larger and expand to multiple lines.  Next command\r\n    searches from C source, excluding comment part.\r\n\r\n        greple --outside '(?s)/\\*.*?\\*/'\r\n\r\n    Next command searches only from POD part of the perl script.\r\n\r\n        greple --inside='(?s)^=.*?(^=cut|\\Z)'\r\n\r\n    When multiple __inside__ and __outside__ regions are specified, those\r\n    regions are mixed up in union way.\r\n\r\n    In multiple color environment, and if single keyword is specified,\r\n    matches in each __--inside__/__outside__ regions are printed in\r\n    different colors.  Forcing this operation with multiple keywords, use\r\n    __--regioncolor__ option.\r\n\r\n- __--inside__=_&function_\r\n- __--outside__=_&function_\r\n\r\n    If the pattern name begins by ampersand (&) character, it is treated\r\n    as a name of subroutine which returns a list of blocks.  Using this\r\n    option, user can use arbitrary function to determine from what part of\r\n    the text they want to search.  User defined function can be defined in\r\n    `.greplerc` file or by module option.\r\n\r\n- __--include__=_pattern_\r\n- __--exclude__=_pattern_\r\n- __--include__=_&function_\r\n- __--exclude__=_&function_\r\n\r\n    __--include__/__exclude__ option behave exactly same as\r\n    __--inside__/__outside__ when used alone.\r\n\r\n    When used in combination, __--include__/__exclude__ are mixed in AND\r\n    manner, while __--inside__/__outside__ are in OR.\r\n\r\n    Thus, in the next example, first line prints all matches, and second\r\n    does none.\r\n\r\n        greple --inside PATTERN --outside PATTERN\r\n\r\n        greple --include PATTERN --exclude PATTERN\r\n\r\n    You can make up desired matches using __--inside__/__outside__ option,\r\n    then remove unnecessary part by __--include__/__exclude__\r\n\r\n- __--strict__\r\n\r\n    Limit the match area strictly.\r\n\r\n    By default, __--block__, __--inside__, __--outside__ option allows\r\n    partial match within the specified area.  For instance,\r\n\r\n        greple --inside and command\r\n\r\n    matches pattern `command` because the part of matched string is\r\n    included in specified inside-area.  Partial match failes when option\r\n    __--strict__ provided, and longer string never matches within shorter\r\n    area.\r\n\r\n- __--join__\r\n- __--joinby__=_string_\r\n\r\n    Convert newline character found in matched string to empty or specifed\r\n    _string_.  Using __--join__ with __-o__ (only-matching) option, you can\r\n    collect searching sentence list in one per line form.  This is almost\r\n    useless for English text but sometimes useful for Japanese text.  For\r\n    example, next command prints the list of KATAKANA words.\r\n\r\n        greple -ho --join '\\p{utf8::InKatakana}[\\n\\p{utf8::InKatakana}]*'\r\n\r\n- __--icode__=_code_\r\n\r\n    Target file is assumed to be encoded in utf8 by default.  Use this\r\n    option to set specific encoding.  When handling Japanese text, you may\r\n    choose from 7bit-jis (jis), euc-jp or shiftjis (sjis).  Multiple code\r\n    can be supplied using multiple option or combined code names with\r\n    space or comma, then file encoding is guessed from those code sets.\r\n    Use encoding name \\`guess' for automatic recognition from default code\r\n    list which is euc-jp and 7bit-jis.  Following commands are all\r\n    equivalent.\r\n\r\n        greple --icode=guess ...\r\n        greple --icode=euc-jp,7bit-jis ...\r\n        greple --icode=euc-jp --icode=7bit-jis ...\r\n\r\n    Default code set are always included suspect code list.  If you have\r\n    just one code adding to suspect list, put + mark before the code name.\r\n    Next example does automatic code detection from euc-kr, ascii, utf8\r\n    and UTF-16/32.\r\n\r\n        greple --icode=+euc-kr ...\r\n\r\n- __--ocode__=_code_\r\n\r\n    Specify output code.  Default is utf8.\r\n\r\n- __--need__=_n_\r\n- __--allow__=_n_\r\n\r\n    Option to compromize matching condition.  Option __--need__ specifies\r\n    the required match count, and __--allow__ the number of negative\r\n    condition to be overlooked.\r\n\r\n        greple --need=2 --allow=1 'foo bar baz -yabba -dabba -doo'\r\n\r\n    Above command prints the line which contains two or more from \\`foo',\r\n    \\`bar' and \\`baz', and does not include more than one of \\`yabba',\r\n    \\`dabba' or \\`doo'.\r\n\r\n    Using option __--need__=_1_, __greple__ produces same result as __grep__\r\n    command.\r\n\r\n        grep -e foo -e bar -e baz\r\n        greple --need=1 -e foo -e bar -e baz\r\n\r\n    When the count _n_ is negative value, it is subtracted from maximum\r\n    value.\r\n\r\n- __--if__=_filter_, __--if__=_EXP_:_filter_:_EXP_:_filter_:...\r\n\r\n    You can specify filter command which is applied to each files before\r\n    search.  If only one filter command is specified, it is applied to all\r\n    files.  If filter information include multiple fields separated by\r\n    colons, first field will be perl expression to check the filename\r\n    saved in variable $\\_.  If it successes, next filter command is pushed.\r\n    These expression and command list can be repeated.\r\n\r\n        greple --if=rev perg\r\n        greple --if='/\\.tar$/:tar tvf -'\r\n\r\n    If the command doesn't accept standard input as processing data, you\r\n    may be able to use special device:\r\n\r\n        greple --if='nm /dev/stdin' crypt /usr/lib/lib*\r\n\r\n    Filters for compressed and gzipped file is set by default unless\r\n    __--noif__ option is given.  Default action is like this:\r\n\r\n        greple --if='s/\\.Z$//:zcat:s/\\.g?z$//:gunzip -c'\r\n\r\n- __--noif__\r\n\r\n    Disable default input filter.  Which means compressed files will not\r\n    be decompressed automatically.\r\n\r\n- __--of__=_filter_\r\n\r\n    Specify output filter commands.\r\n\r\n- __--require__=_filename_\r\n\r\n    Include arbitrary perl program.\r\n\r\n- __--pgp__\r\n\r\n    Invoke PGP decrypt command for files end with .pgp, .gpg or .asc.  PGP\r\n    passphrase is asked only once at the beginning of command execution.\r\n\r\n- __--pgppass__=_phrase_\r\n\r\n    You can specify PGP passphrase by this option.  Generally, it is not\r\n    recommended to use.\r\n\r\n- __--glob__=_pattern_\r\n\r\n    Get files matches to specified pattern and use them as a target files.\r\n    Using __--chdir__ and __--glob__ makes easy to use __greple__ for fixed\r\n    common job.\r\n\r\n- __--chdir__=_directory_\r\n\r\n    Change directory before processing files.  When multiple directories\r\n    are specified in __--chdir__ option, by using wildcard form or\r\n    repeating option, __--glob__ file expantion will be done for every\r\n    directories.\r\n\r\n        greple --chdir '/usr/man/man?' --glob '*.[0-9]' ...\r\n\r\n- __--print__=_function_, __--print__=_sub{...}_\r\n- __--continue__\r\n\r\n    Specify user defined function executed before data print.  Text to be\r\n    printed is replaced by the result of the funcion.  Arbitrary function\r\n    can be defined in `.greplerc` file.  Matched data is placed in\r\n    variable `$_`.  Other information is passed by key-value pair in the\r\n    arguments.  Filename is passed by `file` key.  Matched informaiton is\r\n    passed by `matched` key, in the form of perl array reference:\r\n    `[[start,end],[start,end]...]`.\r\n\r\n    Simplest function is __--print__='_sub{$\\_}_'.  Coloring capability can\r\n    be used like this:\r\n\r\n        # ~/.greplerc\r\n        __CODE__\r\n        sub print_simple {\r\n            my %attr = @_;\r\n            for my $r (reverse @{$attr{matched}}) {\r\n                my($s, $e) = @$r;\r\n                substr($_, $s, $e - $s) = color(substr($_, $s, $e - $s));\r\n            }\r\n            $_;\r\n        }\r\n\r\n    Then, you can use this function in the command line.\r\n\r\n        greple --print=print_simple ...\r\n\r\n- __--readlist__\r\n\r\n    Get filenames from standard input.  Read standard input and use each\r\n    line as a filename for searching.  You can feed the output from other\r\n    command like [find(1)](http://man.he.net/man1/find) for __greple__ with this option.  Next example\r\n    searches string from files modified within 7 days:\r\n\r\n        find . -mtime -7 -print | greple --readlist pattern\r\n\r\n- __--man__\r\n\r\n    Show manual page.\r\n\r\n- __--norc__\r\n\r\n    Do not read startup file: `~/.greplerc`.\r\n\r\n# ENVIRONMENT and STARTUP FILE\r\n\r\nEnvironment variable GREPLEOPTS is used as a default options.  They\r\nare inserted before command line options.\r\n\r\nBefore starting execution, _greple_ reads the file named `.greplerc`\r\non user's home directory.  Following directives can be used.\r\n\r\n- __option__ _name_ string\r\n\r\n    Argument _name_ of \\`option' directive is user defined option name.\r\n    The rest are processed by _shellwords_ routine defined in\r\n    Text::ParseWords module.  Be sure that this module sometimes requires\r\n    escape backslashes.\r\n\r\n    Any kind of string can be used for option name but it is not combined\r\n    with other options.\r\n\r\n        option --fromcode --outside='(?s)\\/\\*.*?\\*\\/'\r\n        option --fromcomment --inside='(?s)\\/\\*.*?\\*\\/'\r\n\r\n    If the option named __default__ is defined, it will be used as a\r\n    default option.\r\n\r\n- __help__ _name_\r\n\r\n    If \\`help' directive is used for same option name, it will be printed\r\n    in usage message.  If the help message is \\`ignore', corresponding line\r\n    won't show up in the usage.\r\n\r\n- __define__ _name_ string\r\n\r\n    Directive \\`define' is almost same as \\`option', but argument is not\r\n    processed by _shellwords_ and treated just a simple text.\r\n    Metacharacters can be included without escaping.  Defined string\r\n    replacement is done only in definition in option argument.  If you\r\n    want to use the word in command line, use option directive instead.\r\n\r\n        define :kana: \\p{utf8::InKatakana}\r\n        option --kanalist --color=never -o --join --re ':kana:[:kana:\\n]+'\r\n        help   --kanalist List up Katakana string\r\n\r\nWhen _greple_ found `__CODE__` line in `.greplerc` file, the rest\r\nof the file is evaluated as a Perl program.  You can define your own\r\nsubroutines which can be used by __--inside__ and __--outside__ options.\r\nFor those subroutines, file content will be provided by global\r\nvariable `$_`.  Expected response from the subroutine is the list of\r\narray references, which is made up by start and end offset pairs.\r\n\r\nFor example, suppose that the following function is defined in your\r\n`.greplerc` file.\r\n\r\n    __CODE__\r\n    sub odd_line {\r\n        my @list;\r\n        my $i;\r\n        while (/.*\\n/g) {\r\n            push(@list, [ $-[0], $+[0] ]) if ++$i % 2;\r\n        }\r\n        @list;\r\n    }\r\n\r\nYou can use next command to search pattern included in odd number\r\nlines.\r\n\r\n    % greple --inside '&odd_line' patten files...\r\n\r\n# MODULE\r\n\r\nModules can be specified only at the beginning of command line by\r\n__-M___module_ option.  Name _module_ is prepended by __App::Greple__,\r\nso place the module file in `App/Greple/` directory in Perl library.\r\n\r\nIf the package name is declared properly, `__DATA__` section in the\r\nmodule file will be interpreted same as `.greplerc` file content.\r\n\r\nSee this sample module code.  This sample define options to search\r\nfrom pod, comment and other segment in Perl script.  Those capability\r\ncan be implemented both in function and macro.\r\n\r\n    package App::Greple::perl;\r\n    \r\n    BEGIN {\r\n        use Exporter   ();\r\n        our ($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS);\r\n    \r\n        $VERSION = sprintf \"%d.%03d\", q$Revision: 6.20 $ =~ /(\\d+)/g;\r\n    \r\n        @ISA         = qw(Exporter);\r\n        @EXPORT      = qw(&pod &comment &podcomment);\r\n        %EXPORT_TAGS = ( );\r\n        @EXPORT_OK   = qw();\r\n    }\r\n    our @EXPORT_OK;\r\n    \r\n    END { }\r\n    \r\n    my $pod_re = qr{^=\\w+(?s:.*?)(?:\\Z|^=cut\\s*\\n)}m;\r\n    my $comment_re = qr{^(?:[ \\t]*#.*\\n)+}m;\r\n    \r\n    sub pod {\r\n        my @list;\r\n        while (/$pod_re/g) {\r\n            push(@list, [ $-[0], $+[0] ] );\r\n        }\r\n        @list;\r\n    }\r\n    sub comment {\r\n        my @list;\r\n        while (/$comment_re/g) {\r\n            push(@list, [ $-[0], $+[0] ] );\r\n        }\r\n        @list;\r\n    }\r\n    sub podcomment {\r\n        my @list;\r\n        while (/$pod_re|$comment_re/g) {\r\n            push(@list, [ $-[0], $+[0] ] );\r\n        }\r\n        @list;\r\n    }\r\n    \r\n    1;\r\n    \r\n    __DATA__\r\n    \r\n    define :comment: ^(\\s*#.*\\n)+\r\n    define :pod: ^=(?s:.*?)(?:\\Z|^=cut\\s*\\n)\r\n    \r\n    #option --pod --inside :pod:\r\n    #option --comment --inside :comment:\r\n    #option --code --outside :pod:|:comment:\r\n    \r\n    option --pod --inside '&pod'\r\n    option --comment --inside '&comment'\r\n    option --code --outside '&podcomment'\r\n\r\nYou can use the module like this:\r\n\r\n    greple -Mperl --pod default greple\r\n\r\n    greple -Mperl --colorful --code --comment --pod default greple\r\n\r\n# HISTORY\r\n\r\nMost capability of __greple__ is derived from __mg__ command, which has\r\nbeen developing from early 1990's by the same author.  Because modern\r\nstandard __grep__ family command becomes to have similar capabilities,\r\nit is a time to clean up entire functionarities, totally remodel the\r\noption interfaces, and change the command name. (2013.11)\r\n\r\n# AUTHOR\r\n\r\nKazumasa Utashiro\r\n\r\n# SEE ALSO\r\n\r\n[grep(1)](http://man.he.net/man1/grep), [perl(1)](http://man.he.net/man1/perl)\r\n\r\n[github](http://kaz-utashiro.github.io/greple/)\r\n\r\n# LICENSE\r\n\r\nCopyright (c) 1991-2014 Kazumasa Utashiro\r\n\r\nUse and redistribution for ANY PURPOSE are granted as long as all\r\ncopyright notices are retained.  Redistribution with modification is\r\nallowed provided that you make your modified version obviously\r\ndistinguishable from the original one.  THIS SOFTWARE IS PROVIDED BY\r\nTHE AUTHOR \\`\\`AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES ARE\r\nDISCLAIMED.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}