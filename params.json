{"name":"Greple","tagline":"greple: grep type command with multiple keywords","body":"# NAME\r\n\r\ngreple - grep with multiple keywords\r\n\r\n# SYNOPSIS\r\n\r\n__greple__ [ __-options__ ] pattern [ file... ]\r\n\r\n    pattern           'positive -negative ?alternative'\r\n\r\n    -e pattern        regex pattern match across line boundary\r\n    -v pattern        regex pattern not to be matched\r\n    --le pattern      lexical expression (same as bare pattern)\r\n    --re pattern      regular expression\r\n    --fe pattern      fixed expression\r\n\r\n## __OPTIONS__\r\n\r\n    -i                ignore case\r\n    -l                list filename only\r\n    -c                print count of matched block only\r\n    -o                print only the matching part\r\n    -n                print line number\r\n    -h                do not display filenames\r\n    -H                always display filenames\r\n    -p                paragraph mode\r\n    -A[n]             after match context\r\n    -B[n]             before match context\r\n    -C[n]             after and before match context\r\n    -f file           file contains search pattern\r\n    -Z                do not uncompress automatically\r\n    -d flags          display info (f:file d:dir c:count m:misc s:stat)\r\n\r\n    --man             show manual page\r\n    --color=when      use termninal color (auto, always, never)\r\n    --colormode=mode  Red, Green, Blue, Cyan, Magenta, Yellow, White,\r\n    \t\t      Standout, bolD, Underline\r\n    --nocolor         Same as --color=never\r\n    --icode=name      specify file encoding (repeatable)\r\n    --ocode=name      specify output encoding\r\n    --block=pattern   specify the block of records\r\n    --blockend=s      specify the block end mark (Default: \"--\\n\")\r\n    --inside=pattern  limit matching area\r\n    --outside=pattern opposite of --inside\r\n    --join            delete newline in the matched part\r\n    --joinby string   replace newline in the matched text by string\r\n    --if=filter       set filter command\r\n    --of=filter       output filter command\r\n    --[no]pgp         remember passphrase and use it for PGP processing\r\n    --pgppass=phrase  pgp passphrase\r\n    --readlist        get filenames from stdin\r\n    --glob=glob       glob target files (repeatable)\r\n    --norc            skip reading startup file\r\n\r\n# DESCRIPTION\r\n\r\n__greple__ has almost the same function as Unix command [egrep(1)](http://man.he.net/man1/egrep) but\r\nthe search is done in the manner similar to search engine.  For\r\nexample, next command print lines those contain all of 'foo' and 'bar'\r\nand 'baz'.\r\n\r\n    greple 'foo bar baz' ...\r\n\r\nEach word can be found in any order and/or any place in the string.\r\nSo this command find all of following texts.\r\n\r\n    foo bar baz\r\n    baz bar foo\r\n    the foo, bar and baz\r\n\r\nIf you want to use OR syntax, prepend question ('?') mark on each\r\ntoken, or use regular expression.\r\n\r\n    greple 'foo bar baz ?yabba ?dabba ?doo'\r\n    greple 'foo bar baz yabba|dabba|doo'\r\n\r\nThis command will print the line which contains all of 'foo', 'bar'\r\nand 'baz' and one or more from 'yabba', 'dabba' or 'doo'.\r\n\r\nNOT operator can be specified by prefixing the token by minus ('-')\r\nsign.  Next example will show the line which contain both 'foo' and\r\nbar' but none of 'yabba' or 'dabba' or 'doo'.  It is ok to put '+'\r\nmark for positive matching pattern.\r\n\r\n    greple 'foo bar -yabba -dabba -doo'\r\n    greple '+foo +bar -yabba|dabba|doo'\r\n\r\nThis can be written as this using __-e__ and __-v__ option.\r\n\r\n    greple -e foo -e bar -v yabba -v dabba -v doo\r\n    greple -e foo -e bar -v 'yabba|dabba|doo'\r\n\r\n## __LINE ACROSS MATCH__\r\n\r\n__greple__ also search the pattern across the line boundaries.  This is\r\nespecially useful to handle Asian multi-byte text.  Japanese text can\r\nbe separated by newline almost any place of the text.  So the search\r\npattern may spread out on multiple lines.  As for ascii text, space\r\ncharacter in the pattern matches any kind of space including newline.\r\nUse __-e__ option to use this capability because space is taken as a\r\ntoken separator in the bare pattern.\r\n\r\n\r\n\r\n# OPTIONS\r\n\r\n## __PATTERNS__\r\n\r\nIf specific option is not provided, __greple__ takes the first argument\r\nas a search pattern specified by __-le__ option.  All of these patterns\r\ncan be specified multiple times.\r\n\r\nCommand itself is written in Perl, and any kind of Perl style regular\r\nexpression can be used in patterns.\r\n\r\n#### __--le__=_pattern_\r\n\r\nTreat the string as a collection of tokens separated by spaces.  Each\r\ntoken is interpreted by the first character.  Token start with '-'\r\nmeans negative pattern, '?' means alternative, optional '+' and\r\nanything other means positive match.\r\n\r\nNext example print lines which contains 'foo' and 'bar', and one or\r\nmore of 'yabba' and 'dabba', and none of 'bar' and 'doo'.\r\n\r\n    greple --le='foo bar -baz ?yabba ?dabba -doo'\r\n\r\nMultiple '?' preceded tokens are treated all mixed together.  That\r\nmeans '?A|B ?C|D' is equivalent to '?A|B|C|D'.  If you want to mean\r\n'(A or B) and (C or D)', use AND syntax instead: 'A|B C|D'.\r\n\r\n#### __-e__ _pattern_, __--and__=_pattern_\r\n\r\nSpecify positive match token.  Next two commands are equivalent.\r\n\r\n    greple 'foo bar baz'\r\n    greple -e foo -e bar -e baz\r\n\r\nFirst character is not interpreted, so next commands will search the\r\npattern '-baz'.\r\n\r\n    greple -e -baz\r\n\r\nSpace characters are treated specially by __-e__ and __-v__ options.\r\nThey are replaced by the pattern which matches any number of\r\nwhite spaces including newline.  So the pattern can be expand to\r\nmultiple lines.  Next commands search the series of word 'foo', 'bar'\r\nand 'baz' even if they are separated by newlines.\r\n\r\n    greple -e 'foo bar baz'\r\n\r\n#### __-v__ _pattern_, __--not__=_pattern_\r\n\r\nSpecify negative match token.  Because it does not affect to the bare\r\npattern argument, you can narrow down the search result like this.\r\n\r\n    greple foo pattern file\r\n    greple foo pattern file -v bar\r\n    greple foo pattern file -v bar -v baz\r\n\r\n#### __--re__=_pattern_\r\n\r\nSpecify regular expression.  No special treatment for space and wide\r\ncharacters.\r\n\r\n#### __--fe__=_pattern_\r\n\r\nSpecify fixed string pattern, like fgrep.\r\n\r\n\r\n\r\n## __GREP LIKE OPTIONS__\r\n\r\n#### __-i__\r\n\r\nIgnore case.\r\n\r\n#### __-l__\r\n\r\nList filename only.\r\n\r\n#### __-c__, __--count__\r\n\r\nPrint count of matched block.\r\n\r\n#### __-n__\r\n\r\nShow line number.\r\n\r\n#### __-h__, __--no-filename__\r\n\r\nDo not display filename.\r\n\r\n#### __-H__\r\n\r\nDisplay filename always.\r\n\r\n#### __-o__\r\n\r\nPrint matched string only.\r\n\r\n#### __-A__[_n_], __--after-context__[=_n_]\r\n\r\n#### __-B__[_n_], __--before-context__[=_n_]\r\n\r\n#### __-C__[_n_], __--context__[=_n_]\r\n\r\nPrint _n_-blocks before/after matched string.  The value _n_ can be\r\nomitted and the default is 2.  When used with paragraph option __-p__,\r\n_n_ means number of paragraphs.\r\n\r\nActually, these options expand the area of logical operation.  It\r\nmeans\r\n\r\n    grep -C1 'foo bar baz'\r\n\r\nmatches following text.\r\n\r\n    foo\r\n    bar\r\n    baz\r\n\r\nMoreover\r\n\r\n    greple -C1 'foo baz'\r\n\r\nalso matches this text, because matching blocks around 'foo' and 'bar'\r\noverlaps each other and makes single block.\r\n\r\n#### __-f__ _file_, __--file__=_file_\r\n\r\nSpecify the file which contains search pattern.  When file contains\r\nmultiple lines, patterns on each lines are search in OR context.  The\r\nline starting with sharp (#) character is ignored.\r\n\r\n#### __--__[__no__]__decompress__\r\n\r\nSwitch for handling compressed files.  Default is true.\r\n\r\n#### __--color__=_auto_|_always_|_never_, __--nocolor__\r\n\r\nUse terminal color capability to emphasize the matched text.  Default\r\nis 'auto': effective when STDOUT is terminal, not otherwise.  Option\r\nvalue 'always' and 'never' will work as expected.\r\n\r\nOption __--nocolor__ is alias for __--color__=_never_.\r\n\r\n#### __--colormode__=_RGBCYMWrgbcymwUBR_, __--quote__=_start_,_end_\r\n\r\nSpecify color mode.  Use combination string from R(ed), G(reen),\r\nB(lue), C(yan), M(agenta), Y(ellow), W(hite), U(nderline), (bol)D,\r\nS(tandout).  Lowercase form of RGBW means background color.  Default\r\nis RD: RED and BOLD.\r\n\r\nIf the mode string contains comma ',' character, they are used to\r\nquote the matched string.  If you want to quote the pattern by angle\r\nbracket, use like this.\r\n\r\n    greple --quote='<,>' pattern\r\n\r\n\r\n\r\n## __OTHER OPTIONS__\r\n\r\n#### __-p__, __--paragraph__\r\n\r\nPrint the paragraph which contains the pattern.  Each paragraph is\r\ndelimited by two or more successive newline characters by default.  Be\r\naware that an empty line is not paragraph delimiter if which contains\r\nspace characters.  Example:\r\n\r\n    greple -np 'setuid script' /usr/man/catl/perl.l\r\n\r\n    greple -pe '^struct sockaddr' /usr/include/sys/socket.h\r\n\r\nIt changes the unit of context specified by __-A__, __-B__, __-C__\r\noptions.\r\n\r\n#### __--block__=_pattern_, __--block__=_&sub_\r\n\r\nSpecify the record block to display.\r\n\r\nNext command prints entire file because it handles the whole text as a\r\nsingle large block.\r\n\r\n    greple --block='(?s).*'\r\n\r\nNext is almost same as __--paragraph__ option.\r\n\r\n    greple --block='(.+\\n)+'\r\n\r\nNext command treat the data as a series of 10-line blocks.\r\n\r\n    greple -n --block='(.*\\n){1,10}'\r\n\r\nWhen blocks are not continuous and there are gaps between them, the\r\nmatch occurred outside blocks are ignored.\r\n\r\nIf multiple block options are supplied, overlapping blocks are merged\r\ninto single block.\r\n\r\nPlease be aware that this option is sometimes quite time consuming,\r\nbecause it finds all blocks before processing.\r\n\r\n#### __--blockend__=_string_\r\n\r\nChange the end mark displayed after __-pABC__ or __--block__ options.\r\nDefault value is \"--\\n\".\r\n\r\n#### __--inside__=_pattern_\r\n\r\n#### __--outside__=_pattern_\r\n\r\nOption __--inside__ and __--outside__ limit the text area to be matched.\r\nFor simple example, if you want to find string 'and' not in the word\r\n'command', it can be done like this.\r\n\r\n    greple --outside=command and\r\n\r\nThe block can be larger and expand to multiple lines.  Next command\r\nsearches from C source, excluding comment part.\r\n\r\n    greple --outside '(?s)/\\*.*?\\*/'\r\n\r\nNext command searches only from POD part of the perl script.\r\n\r\n    greple --inside='(?s)^=.*?(^=cut|\\Z)'\r\n\r\n#### __--inside__=_&function_\r\n\r\n#### __--outside__=_&function_\r\n\r\nIf the pattern name begins by ampersand (&) character, it is treated\r\nas a name of subroutine which returns a list of blocks to exclude.\r\nUsing this option, user can use arbitrary function to determine from\r\nwhat part of the text they want to search.  User defined function is\r\nwritten in `.greplerc` file or explicitly included by __--require__\r\noption.\r\n\r\n    greple --require mycode.pl --outside '&myfunc' pattern *\r\n\r\nArgument can be specified after function name with '=' character.\r\nNext example is equivalent to the above example.\r\n\r\n    sub myfunc {\r\n        my($pattern) = @_;\r\n        my @matched;\r\n        my $re = qr/$pattern/m;\r\n        while (/$re/g) {\r\n            push(@matched, [ $-[0], $+[0] ]);\r\n        }\r\n        @matched;\r\n    }\r\n\r\n    greple --outside '&myfunc=(?s)/\\*.*?\\*/' if *.c\r\n\r\n__--outside__ and __--inside__ option can be specified mixed together\r\nand multiple times.\r\n\r\n#### __--join__\r\n\r\n#### __--joinby__=_string_\r\n\r\nConvert newline character found in matched string to empty or specifed\r\n_string_.  Using __--join__ with __-o__ (only-matching) option, you can\r\ncollect searching sentence list in one per line form.  This is almost\r\nuseless for English text but sometimes useful for Japanese text.  For\r\nexample next command prints the list of KATAKANA words.\r\n\r\n    greple -ho --join '\\p{utf8::InKatakana}[\\n\\p{utf8::InKatakana}]*'\r\n\r\n#### __--icode__=_code_\r\n\r\nTarget file is assumed to be encoded in utf8 by default.  Use this\r\noption to set specific encoding.  When handling Japanese text, you may\r\nchoose from 7bit-jis (jis), euc-jp or shiftjis (sjis).  Multiple code\r\ncan be supplied using multiple option or combined code names with\r\nspace or comma, then file encoding is guessed from those code sets.\r\nUse encoding name 'guess' for automatic recognition from default code\r\nlist which is euc-jp and 7bit-jis.  Following commands are all\r\nequivalent.\r\n\r\n    greple --icode=guess ...\r\n    greple --icode=euc-jp,7bit-jis ...\r\n    greple --icode=euc-jp --icode=7bit-jis ...\r\n\r\nDefault code set are always included suspect code list.  If you have\r\njust one code adding to suspect list, put + mark before the code name.\r\nNext example does automatic code detection from euc-kr, ascii, utf8\r\nand UTF-16/32.\r\n\r\n    greple --icode=+euc-kr ...\r\n\r\n#### __--ocode__=_code_\r\n\r\nSpecify output code.  Default is utf8.\r\n\r\n#### __--cut__=_n_, __--allow__=_n_\r\n\r\nOption to compromize matching condition.  Option __--cut__ specifiy the\r\nnumber to cut down positive match count, and __--allow__ is the number\r\nof negative condition to be overlooked.\r\n\r\n    greple --cut=1 --allow=1 'foo bar baz -yabba -dabba -doo'\r\n\r\nAbove command prints the line which contains two or more from 'foo',\r\n'bar' and 'baz', and does not include more than one of 'yabba',\r\n'dabba' or 'doo'.\r\n\r\n#### __--if__=_filter_, __--if__=_EXP_:_filter_:_EXP_:_filter_:...\r\n\r\nYou can specify filter command which is applied to each files before\r\nsearch.  If only one filter command is specified, it is applied to all\r\nfiles.  If filter information include multiple fields separated by\r\ncolons, first field will be perl expression to check the filename\r\nsaved in variable $_.  If it successes, next filter command is pushed.\r\nThese expression and command list can be repeated.\r\n\r\n    greple --if=rev perg\r\n    greple --if='/\\.tar$/:tar tvf -'\r\n\r\nIf the command doesn't accept standard input as processing data, you\r\nmay be able to use special device:\r\n\r\n    greple --if='nm /dev/stdin' crypt /usr/lib/lib*\r\n\r\nFilters for compressed and gzipped file is set by default unless\r\n__--nodecompress__ option is given.  Default action is like this:\r\n\r\n    greple --if='s/\\.Z$//:zcat:s/\\.g?z$//:gunzip -c'\r\n\r\n#### __--of__=_filter_\r\n\r\nSpecify output filter commands.\r\n\r\n#### __--require__=_filename_\r\n\r\nInclude arbitrary perl program.\r\n\r\n#### __--pgp__\r\n\r\nInvoke PGP decrypt command for files end with .pgp, .gpg or .asc.  PGP\r\npassphrase is asked only once at the beginning of command execution.\r\n\r\n#### __--pgppass__=_phrase_\r\n\r\nYou can specify PGP passphrase by this option.  Generally, it is not\r\nrecommended to use.\r\n\r\n#### __--chdir__=_directory_\r\n\r\nChange directory before processing.\r\n\r\n#### __--glob__=_pattern_\r\n\r\nGet files matches to specified pattern and use them as a target\r\nfiles.  Using __--chdir__ and __--glob__ makes easy to use __greple__ for\r\nfixed common job.\r\n\r\n#### __--readlist__\r\n\r\nGet filenames from standard input.  Read standard input and use each\r\nline as a filename for searching.  You can feed the output from other\r\ncommand like [find(1)](http://man.he.net/man1/find) for __greple__ with this option.  Next example\r\nsearches string from files modified within 7 days:\r\n\r\n    find . -mtime -7 -print | greple -S pattern\r\n\r\n#### __--man__\r\n\r\nShow manual page.\r\n\r\n#### __--norc__\r\n\r\nDo not read startup file: `~/.greplerc`.\r\n\r\n#### __-d__ _flags_\r\n\r\nDisplay informations.  Various kind of debug, diagnostic, monitor\r\ninformation can be display by giving appropriate flag to -d option.\r\n\r\n    f: processing file name\r\n    s: statistic information\r\n    m: misc debug information\r\n    o: option related information\r\n    p: run 'ps' command before termination (on Unix)\r\n\r\n\r\n\r\n# ENVIRONMENT and STARTUP FILE\r\n\r\nEnvironment variable GREPLEOPTS is used as a default options.  They\r\nare inserted before command line options.\r\n\r\nBefore starting execution, _greple_ reads the file named `.greplerc`\r\non user's home directory.  In rc file, user can define own options.\r\nThere are three directives rc file: 'option', 'define' and 'help'.\r\nFirst argument of 'option' directive is user defined option name.  The\r\nrest are processed by _shellwords_ routine defined by\r\nText::ParseWords module.  Be sure that this module sometimes requires\r\nescape backslashes.\r\n\r\nAny kind of string can be used for option name but it is not combined\r\nwith other options.\r\n\r\n    option --fromcode --outside='(?s)\\/\\*.*?\\*\\/'\r\n    option --fromcomment --inside='(?s)\\/\\*.*?\\*\\/'\r\n\r\nAnother directive 'define' is almost same as 'option', but argument is\r\nnot processed by _shellwords_ and treated just a simple text.\r\nMetacharacters can be included without escaping.  Defined string\r\nreplacement is done only in definition in option argument.  If you\r\nwant to use the word in command line, use option directive instead.\r\nIf 'help' directive is used for same option name, it will be printed\r\nin usage message.\r\n\r\n    define :kana: \\p{utf8::InKatakana}\r\n    option --kanalist --color=never -o --join --re ':kana:[:kana:\\n]+'\r\n    help   --kanalist List up Katakana string\r\n\r\nWhen _greple_ found '__CODE__' line in `.greplerc` file, the rest of\r\nthe file is evaluated as a Perl program.  You can define your own\r\nsubroutines which can be used by --inside and --outside options.  For\r\nthose subroutines, file content will be provided by global variable\r\n$_.  Expected response from the subroutine is the list of numbers,\r\nwhich is made up by start and end offset pairs.\r\n\r\nFor example, suppose that the following function is defined in your\r\n`.greplerc` file.\r\n\r\n    __CODE__\r\n    sub odd_line {\r\n        my @list;\r\n        my $i;\r\n        while (/.*\\n/g) {\r\n            push(@list, [ $-[0], $+[0] ]) if ++$i % 2;\r\n        }\r\n        @list;\r\n    }\r\n\r\nYou can use next command to search pattern included in odd number\r\nlines.\r\n\r\n    % greple --inside &odd_line patten files...\r\n\r\nIf you do not want to evaluate those programs in all invocation of the\r\ncommand, use --require option to include arbitrary perl program files.\r\n\r\n\r\n\r\n# HISTORY\r\n\r\nMost capability of __greple__ is derived from __mg__ command, which has\r\nbeen developing from early 1990's by the same author.  Because modern\r\nstandard __grep__ family command becomes to have similar capabilities,\r\nit is a time to clean up entire functionarities, totally remodel the\r\noption interfaces, and change the command name. (2013.11)\r\n\r\n# AUTHOR\r\n\r\nKazumasa Utashiro\r\n\r\n\r\n\r\n# SEE ALSO\r\n\r\n[grep(1)](http://man.he.net/man1/grep), [perl(1)](http://man.he.net/man1/perl)\r\n\r\n\r\n\r\n# LICENSE\r\n\r\nCopyright (c) 1991-2013 Kazumasa Utashiro\r\n\r\nUse and redistribution for ANY PURPOSE are granted as long as all\r\ncopyright notices are retained.  Redistribution with modification is\r\nallowed provided that you make your modified version obviously\r\ndistinguishable from the original one.  THIS SOFTWARE IS PROVIDED BY\r\nTHE AUTHOR ''AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES ARE\r\nDISCLAIMED.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}