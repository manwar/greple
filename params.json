{"name":"Greple","tagline":"greple: grep type command with multiple keywords","body":"# NAME\r\n\r\ngreple - grep with multiple keywords\r\n\r\n# SYNOPSIS\r\n\r\n__greple__ [__-M___module_] [ __-options__ ] pattern [ file... ]\r\n\r\n    pattern           'positive -negative ?alternative'\r\n\r\n    -e pattern        regex pattern match across line boundary\r\n    -v pattern        regex pattern not to be matched\r\n    --le pattern      lexical expression (same as bare pattern)\r\n    --re pattern      regular expression\r\n    --fe pattern      fixed expression\r\n\r\n## __OPTIONS__\r\n\r\n    -i                   ignore case\r\n    -l                   list filename only\r\n    -c                   print count of matched block only\r\n    -n                   print line number\r\n    -h                   do not display filenames\r\n    -H                   always display filenames\r\n    --inside=pattern     limit matching area\r\n    --outside=pattern    opposite to --inside\r\n    --revinside=pattern  inside reverse pattern\r\n    --revoutside=pattern outside reverse pattern\r\n    --strict             strict mode for --inside/outside --block\r\n    --join               delete newline in the matched part\r\n    --joinby=string      replace newline in the matched text by string\r\n\r\n    --need=n             required positive match count\r\n    --allow=n            acceptable negative match count\r\n\r\n    --color=when         use terminal color (auto, always, never)\r\n    --nocolor            same as --color=never\r\n    --colormode=mode     R, G, B, C, M, Y, W, Standout, bolD, Underline\r\n    --colorful           same as --colormode 'RD GD BD CD MD YD'\r\n    --random             random color\r\n    --regioncolor        color by region\r\n\r\n    -o                   print only the matching part\r\n    -p                   paragraph mode\r\n    -A[n]                after match context\r\n    -B[n]                before match context\r\n    -C[n]                after and before match context\r\n    --all                print whole data\r\n    --block=pattern      specify the block of records\r\n    --blockend=s         specify the block end mark (Default: \"--\\n\")\r\n\r\n    -f file              file contains search pattern\r\n    -d flags             display info (f:file d:dir c:count m:misc s:stat)\r\n    --man                show manual page\r\n    --icode=name         specify file encoding\r\n    --ocode=name         specify output encoding\r\n    --if=filter          set filter command\r\n    --of=filter          output filter command\r\n    --[no]pgp            decrypt and find PGP file (Default: false)\r\n    --pgppass=phrase     pgp passphrase\r\n    --[no]decompress     process compressed data (Default: true)\r\n    --readlist           get filenames from stdin\r\n    --chdir              change directory before search\r\n    --glob=glob          glob target files\r\n    --print=func         print function\r\n    --continue           continue after print function\r\n    --norc               skip reading startup file\r\n\r\n# DESCRIPTION\r\n\r\n__greple__ has almost the same function as Unix command [egrep(1)](http://man.he.net/man1/egrep) but\r\nthe search is done in the manner similar to search engine.  For\r\nexample, next command print lines those contain all of 'foo' and 'bar'\r\nand 'baz'.\r\n\r\n    greple 'foo bar baz' ...\r\n\r\nEach word can be found in any order and/or any place in the string.\r\nSo this command find all of following texts.\r\n\r\n    foo bar baz\r\n    baz bar foo\r\n    the foo, bar and baz\r\n\r\nIf you want to use OR syntax, prepend question ('?') mark on each\r\ntoken, or use regular expression.\r\n\r\n    greple 'foo bar baz ?yabba ?dabba ?doo'\r\n    greple 'foo bar baz yabba|dabba|doo'\r\n\r\nThis command will print the line which contains all of 'foo', 'bar'\r\nand 'baz' and one or more from 'yabba', 'dabba' or 'doo'.\r\n\r\nNOT operator can be specified by prefixing the token by minus ('-')\r\nsign.  Next example will show the line which contain both 'foo' and\r\nbar' but none of 'yabba' or 'dabba' or 'doo'.  It is ok to put '+'\r\nmark for positive matching pattern.\r\n\r\n    greple 'foo bar -yabba -dabba -doo'\r\n    greple '+foo +bar -yabba|dabba|doo'\r\n\r\nThis can be written as this using __-e__ and __-v__ option.\r\n\r\n    greple -e foo -e bar -v yabba -v dabba -v doo\r\n    greple -e foo -e bar -v 'yabba|dabba|doo'\r\n\r\n## __LINE ACROSS MATCH__\r\n\r\n__greple__ also search the pattern across the line boundaries.  This is\r\nespecially useful to handle Asian multi-byte text.  Japanese text can\r\nbe separated by newline almost any place of the text.  So the search\r\npattern may spread out on multiple lines.  As for ascii text, space\r\ncharacter in the pattern matches any kind of space including newline.\r\nUse __-e__ option to use this capability because space is taken as a\r\ntoken separator in the bare pattern.\r\n\r\n\r\n\r\n# OPTIONS\r\n\r\n## __PATTERNS__\r\n\r\nIf specific option is not provided, __greple__ takes the first argument\r\nas a search pattern specified by __-le__ option.  All of these patterns\r\ncan be specified multiple times.\r\n\r\nCommand itself is written in Perl, and any kind of Perl style regular\r\nexpression can be used in patterns.\r\n\r\n#### __--le__=_pattern_\r\n\r\nTreat the string as a collection of tokens separated by spaces.  Each\r\ntoken is interpreted by the first character.  Token start with '-'\r\nmeans negative pattern, '?' means alternative, optional '+' and\r\nanything other means positive match.\r\n\r\nNext example print lines which contains 'foo' and 'bar', and one or\r\nmore of 'yabba' and 'dabba', and none of 'bar' and 'doo'.\r\n\r\n    greple --le='foo bar -baz ?yabba ?dabba -doo'\r\n\r\nMultiple '?' preceded tokens are treated all mixed together.  That\r\nmeans '?A|B ?C|D' is equivalent to '?A|B|C|D'.  If you want to mean\r\n'(A or B) and (C or D)', use AND syntax instead: 'A|B C|D'.\r\n\r\n#### __-e__ _pattern_, __--and__=_pattern_\r\n\r\nSpecify positive match token.  Next two commands are equivalent.\r\n\r\n    greple 'foo bar baz'\r\n    greple -e foo -e bar -e baz\r\n\r\nFirst character is not interpreted, so next commands will search the\r\npattern '-baz'.\r\n\r\n    greple -e -baz\r\n\r\nSpace characters are treated specially by __-e__ and __-v__ options.\r\nThey are replaced by the pattern which matches any number of\r\nwhite spaces including newline.  So the pattern can be expand to\r\nmultiple lines.  Next commands search the series of word 'foo', 'bar'\r\nand 'baz' even if they are separated by newlines.\r\n\r\n    greple -e 'foo bar baz'\r\n\r\n#### __-v__ _pattern_, __--not__=_pattern_\r\n\r\nSpecify negative match token.  Because it does not affect to the bare\r\npattern argument, you can narrow down the search result like this.\r\n\r\n    greple foo pattern file\r\n    greple foo pattern file -v bar\r\n    greple foo pattern file -v bar -v baz\r\n\r\n#### __--re__=_pattern_\r\n\r\nSpecify regular expression.  No special treatment for space and wide\r\ncharacters.\r\n\r\n#### __--fe__=_pattern_\r\n\r\nSpecify fixed string pattern, like fgrep.\r\n\r\n\r\n\r\n## __GREP LIKE OPTIONS__\r\n\r\n#### __-i__\r\n\r\nIgnore case.\r\n\r\n#### __-l__\r\n\r\nList filename only.\r\n\r\n#### __-c__, __--count__\r\n\r\nPrint count of matched block.\r\n\r\n#### __-n__\r\n\r\nShow line number.\r\n\r\n#### __-h__, __--no-filename__\r\n\r\nDo not display filename.\r\n\r\n#### __-H__\r\n\r\nDisplay filename always.\r\n\r\n#### __-o__\r\n\r\nPrint matched string only.\r\n\r\n#### __-A__[_n_], __--after-context__[=_n_]\r\n\r\n#### __-B__[_n_], __--before-context__[=_n_]\r\n\r\n#### __-C__[_n_], __--context__[=_n_]\r\n\r\nPrint _n_-blocks before/after matched string.  The value _n_ can be\r\nomitted and the default is 2.  When used with paragraph option __-p__,\r\n_n_ means number of paragraphs.\r\n\r\nActually, these options expand the area of logical operation.  It\r\nmeans\r\n\r\n    grep -C1 'foo bar baz'\r\n\r\nmatches following text.\r\n\r\n    foo\r\n    bar\r\n    baz\r\n\r\nMoreover\r\n\r\n    greple -C1 'foo baz'\r\n\r\nalso matches this text, because matching blocks around 'foo' and 'bar'\r\noverlaps each other and makes single block.\r\n\r\n#### __-f__ _file_, __--file__=_file_\r\n\r\nSpecify the file which contains search pattern.  When file contains\r\nmultiple lines, patterns on each lines are search in OR context.  The\r\nline starting with sharp (#) character is ignored.\r\n\r\n#### __--__[__no__]__decompress__\r\n\r\nSwitch for handling compressed files.  Default is true.\r\n\r\n#### __--color__=_auto_|_always_|_never_, __--nocolor__\r\n\r\nUse terminal color capability to emphasize the matched text.  Default\r\nis 'auto': effective when STDOUT is a terminal and option __-o__ is not\r\ngiven, not otherwise.  Option value 'always' and 'never' will work as\r\nexpected.\r\n\r\nOption __--nocolor__ is alias for __--color__=_never_.\r\n\r\n#### __--colormode__=_RGBCYMWrgbcymwUBR_, __--quote__=_start_,_end_\r\n\r\nSpecify color mode.  Use combination string from R(ed), G(reen),\r\nB(lue), C(yan), M(agenta), Y(ellow), W(hite), U(nderline), (bol)D,\r\nS(tandout).  Lowercase form of RGBCMYW means background color.\r\nDefault is RD: RED and BOLD.\r\n\r\nIf the mode string contains comma ',' character, they are used to\r\nquote the matched string.  If you want to quote the pattern by angle\r\nbracket, use like this.\r\n\r\n    greple --quote='<,>' pattern\r\n\r\nOption __--quote__ is an alias for __--colormode__, but it set the\r\noption __--color__=_always_ at the same time.\r\n\r\nMultiple colors can be specified separating by white spaces.  Those\r\ncolors will be applied for each pattern keywords.  Next command will\r\nshow word 'foo' in red, 'bar' in green and 'baz' in blue.\r\n\r\n    greple --colormode='R G B' 'foo bar baz' ...\r\n\r\n#### __--colorful__\r\n\r\nShortcut for __--colormode__='_RD GD BD CD MD YD_'\r\n\r\n\r\n\r\n## __OTHER OPTIONS__\r\n\r\n#### __-p__, __--paragraph__\r\n\r\nPrint the paragraph which contains the pattern.  Each paragraph is\r\ndelimited by two or more successive newline characters by default.  Be\r\naware that an empty line is not paragraph delimiter if which contains\r\nspace characters.  Example:\r\n\r\n    greple -np 'setuid script' /usr/man/catl/perl.l\r\n\r\n    greple -pe '^struct sockaddr' /usr/include/sys/socket.h\r\n\r\nIt changes the unit of context specified by __-A__, __-B__, __-C__\r\noptions.\r\n\r\n#### __--all__\r\n\r\nTreat entire file contents as a single block.  This is almost\r\nidentical to following command.\r\n\r\n    greple --block='(?s).*'\r\n\r\n#### __--block__=_pattern_, __--block__=_&sub_\r\n\r\nSpecify the record block to display.  Default block is a single line.\r\n\r\nNext is almost same as __--paragraph__ option.\r\n\r\n    greple --block='(.+\\n)+'\r\n\r\nNext command treat the data as a series of 10-line blocks.\r\n\r\n    greple -n --block='(.*\\n){1,10}'\r\n\r\nWhen blocks are not continuous and there are gaps between them, the\r\nmatch occurred outside blocks are ignored.\r\n\r\nIf multiple block options are supplied, overlapping blocks are merged\r\ninto single block.\r\n\r\nPlease be aware that this option is sometimes quite time consuming,\r\nbecause it finds all blocks before processing.\r\n\r\n#### __--blockend__=_string_\r\n\r\nChange the end mark displayed after __-pABC__ or __--block__ options.\r\nDefault value is \"--\\n\".\r\n\r\n#### __--inside__=_pattern_\r\n\r\n#### __--outside__=_pattern_\r\n\r\nOption __--inside__ and __--outside__ limit the text area to be matched.\r\nFor simple example, if you want to find string 'and' not in the word\r\n'command', it can be done like this.\r\n\r\n    greple --outside=command and\r\n\r\nThe block can be larger and expand to multiple lines.  Next command\r\nsearches from C source, excluding comment part.\r\n\r\n    greple --outside '(?s)/\\*.*?\\*/'\r\n\r\nNext command searches only from POD part of the perl script.\r\n\r\n    greple --inside='(?s)^=.*?(^=cut|\\Z)'\r\n\r\nWhen multiple __inside__ and __outside__ regions are specified, those\r\nregions are mixed up in union way.\r\n\r\nIn multiple color environment, and if single keyword is specified,\r\nmatches in each __--inside__/__outside__ regions are printed in\r\ndifferent colors.  Forcing this operation with multiple keywords, use\r\n__--regioncolor__ option.\r\n\r\n#### __--inside__=_&function_\r\n\r\n#### __--outside__=_&function_\r\n\r\nIf the pattern name begins by ampersand (&) character, it is treated\r\nas a name of subroutine which returns a list of blocks.  Using this\r\noption, user can use arbitrary function to determine from what part of\r\nthe text they want to search.  User defined function can be defined in\r\n`.greplerc` file or by module option.\r\n\r\n#### __--include__=_pattern_\r\n\r\n#### __--exclude__=_pattern_\r\n\r\n#### __--include__=_&function_\r\n\r\n#### __--exclude__=_&function_\r\n\r\n__--include__/__exclude__ option behave exactly same as\r\n__--inside__/__outside__ when used alone.\r\n\r\nWhen used in combination, __--include__/__exclude__ are mixed in AND\r\nmanner, while __--inside__/__outside__ are in OR.\r\n\r\nThus, in the next example, first line prints all matches, and second\r\ndoes none.\r\n\r\n    greple --inside PATTERN --outside PATTERN\r\n\r\n    greple --include PATTERN --exclude PATTERN\r\n\r\nYou can make up desired matches using __--inside__/__outside__ option,\r\nthen remove unnecessary part by __--include__/__exclude__\r\n\r\n#### __--strict__\r\n\r\nLimit the match area strictly.\r\n\r\nBy default, __--block__, __--inside__, __--outside__ option allows\r\npartial match within the specified area.  For instance,\r\n\r\n    greple --inside and command\r\n\r\nmatches pattern `command` because the part of matched string is\r\nincluded in specified inside-area.  Partial match failes when option\r\n__--strict__ provided, and longer string never matches within shorter\r\narea.\r\n\r\n#### __--join__\r\n\r\n#### __--joinby__=_string_\r\n\r\nConvert newline character found in matched string to empty or specifed\r\n_string_.  Using __--join__ with __-o__ (only-matching) option, you can\r\ncollect searching sentence list in one per line form.  This is almost\r\nuseless for English text but sometimes useful for Japanese text.  For\r\nexample, next command prints the list of KATAKANA words.\r\n\r\n    greple -ho --join '\\p{utf8::InKatakana}[\\n\\p{utf8::InKatakana}]*'\r\n\r\n#### __--icode__=_code_\r\n\r\nTarget file is assumed to be encoded in utf8 by default.  Use this\r\noption to set specific encoding.  When handling Japanese text, you may\r\nchoose from 7bit-jis (jis), euc-jp or shiftjis (sjis).  Multiple code\r\ncan be supplied using multiple option or combined code names with\r\nspace or comma, then file encoding is guessed from those code sets.\r\nUse encoding name 'guess' for automatic recognition from default code\r\nlist which is euc-jp and 7bit-jis.  Following commands are all\r\nequivalent.\r\n\r\n    greple --icode=guess ...\r\n    greple --icode=euc-jp,7bit-jis ...\r\n    greple --icode=euc-jp --icode=7bit-jis ...\r\n\r\nDefault code set are always included suspect code list.  If you have\r\njust one code adding to suspect list, put + mark before the code name.\r\nNext example does automatic code detection from euc-kr, ascii, utf8\r\nand UTF-16/32.\r\n\r\n    greple --icode=+euc-kr ...\r\n\r\n#### __--ocode__=_code_\r\n\r\nSpecify output code.  Default is utf8.\r\n\r\n#### __--need__=_n_\r\n\r\n#### __--allow__=_n_\r\n\r\nOption to compromize matching condition.  Option __--need__ specifies\r\nthe required match count, and __--allow__ the number of negative\r\ncondition to be overlooked.\r\n\r\n    greple --need=2 --allow=1 'foo bar baz -yabba -dabba -doo'\r\n\r\nAbove command prints the line which contains two or more from 'foo',\r\n'bar' and 'baz', and does not include more than one of 'yabba',\r\n'dabba' or 'doo'.\r\n\r\nUsing option __--need__=_1_, __greple__ produces same result as __grep__\r\ncommand.\r\n\r\n    grep -e foo -e bar -e baz\r\n    greple --need=1 -e foo -e bar -e baz\r\n\r\nWhen the count _n_ is negative value, it is subtracted from maximum\r\nvalue.\r\n\r\n#### __--if__=_filter_, __--if__=_EXP_:_filter_:_EXP_:_filter_:...\r\n\r\nYou can specify filter command which is applied to each files before\r\nsearch.  If only one filter command is specified, it is applied to all\r\nfiles.  If filter information include multiple fields separated by\r\ncolons, first field will be perl expression to check the filename\r\nsaved in variable $_.  If it successes, next filter command is pushed.\r\nThese expression and command list can be repeated.\r\n\r\n    greple --if=rev perg\r\n    greple --if='/\\.tar$/:tar tvf -'\r\n\r\nIf the command doesn't accept standard input as processing data, you\r\nmay be able to use special device:\r\n\r\n    greple --if='nm /dev/stdin' crypt /usr/lib/lib*\r\n\r\nFilters for compressed and gzipped file is set by default unless\r\n__--nodecompress__ option is given.  Default action is like this:\r\n\r\n    greple --if='s/\\.Z$//:zcat:s/\\.g?z$//:gunzip -c'\r\n\r\n#### __--of__=_filter_\r\n\r\nSpecify output filter commands.\r\n\r\n#### __--require__=_filename_\r\n\r\nInclude arbitrary perl program.\r\n\r\n#### __--pgp__\r\n\r\nInvoke PGP decrypt command for files end with .pgp, .gpg or .asc.  PGP\r\npassphrase is asked only once at the beginning of command execution.\r\n\r\n#### __--pgppass__=_phrase_\r\n\r\nYou can specify PGP passphrase by this option.  Generally, it is not\r\nrecommended to use.\r\n\r\n#### __--glob__=_pattern_\r\n\r\nGet files matches to specified pattern and use them as a target files.\r\nUsing __--chdir__ and __--glob__ makes easy to use __greple__ for fixed\r\ncommon job.\r\n\r\n#### __--chdir__=_directory_\r\n\r\nChange directory before processing files.  When multiple directories\r\nare specified in __--chdir__ option, by using wildcard form or\r\nrepeating option, __--glob__ file expantion will be done for every\r\ndirectories.\r\n\r\n    greple --chdir '/usr/man/man?' --glob '*.[0-9]' ...\r\n\r\n#### __--print__=_function_, __--print__=_sub{...}_\r\n\r\n#### __--continue__\r\n\r\nSpecify user defined function executed before data print.  Text to be\r\nprinted is replaced by the result of the funcion.  Arbitrary function\r\ncan be defined in `.greplerc` file.  Matched data is placed in\r\nvariable `$_`.  Other information is passed by key-value pair in the\r\narguments.  Filename is passed by `file` key.  Matched informaiton is\r\npassed by `matched` key, in the form of perl array reference:\r\n`[[start,end],[start,end]...]`.\r\n\r\nSimplest function is __--print__='_sub{$_}_'.  Coloring capability can\r\nbe used like this:\r\n\r\n    # ~/.greplerc\r\n    __CODE__\r\n    sub print_simple {\r\n        my %attr = @_;\r\n        for my $r (reverse @{$attr{matched}}) {\r\n            my($s, $e) = @$r;\r\n            substr($_, $s, $e - $s) = color(substr($_, $s, $e - $s));\r\n        }\r\n        $_;\r\n    }\r\n\r\nThen, you can use this function in the command line.\r\n\r\n    greple --print=print_simple ...\r\n\r\n#### __--readlist__\r\n\r\nGet filenames from standard input.  Read standard input and use each\r\nline as a filename for searching.  You can feed the output from other\r\ncommand like [find(1)](http://man.he.net/man1/find) for __greple__ with this option.  Next example\r\nsearches string from files modified within 7 days:\r\n\r\n    find . -mtime -7 -print | greple --readlist pattern\r\n\r\n#### __--man__\r\n\r\nShow manual page.\r\n\r\n#### __--norc__\r\n\r\nDo not read startup file: `~/.greplerc`.\r\n\r\n#### __-d__ _flags_\r\n\r\nDisplay informations.  Various kind of debug, diagnostic, monitor\r\ninformation can be display by giving appropriate flag to -d option.\r\n\r\n    f: processing file name\r\n    s: statistic information\r\n    m: misc debug information\r\n    o: option related information\r\n    p: run 'ps' command before termination (on Unix)\r\n\r\n\r\n\r\n# ENVIRONMENT and STARTUP FILE\r\n\r\nEnvironment variable GREPLEOPTS is used as a default options.  They\r\nare inserted before command line options.\r\n\r\nBefore starting execution, _greple_ reads the file named `.greplerc`\r\non user's home directory.  Following directives can be used.\r\n\r\n#### __option__ _name_ string\r\n\r\nArgument _name_ of 'option' directive is user defined option name.\r\nThe rest are processed by _shellwords_ routine defined in\r\nText::ParseWords module.  Be sure that this module sometimes requires\r\nescape backslashes.\r\n\r\nAny kind of string can be used for option name but it is not combined\r\nwith other options.\r\n\r\n    option --fromcode --outside='(?s)\\/\\*.*?\\*\\/'\r\n    option --fromcomment --inside='(?s)\\/\\*.*?\\*\\/'\r\n\r\nIf the option named __default__ is defined, it will be used as a\r\ndefault option.\r\n\r\n#### __help__ _name_\r\n\r\nIf 'help' directive is used for same option name, it will be printed\r\nin usage message.  If the help message is 'ignore', corresponding line\r\nwon't show up in the usage.\r\n\r\n#### __define__ _name_ string\r\n\r\nDirective 'define' is almost same as 'option', but argument is not\r\nprocessed by _shellwords_ and treated just a simple text.\r\nMetacharacters can be included without escaping.  Defined string\r\nreplacement is done only in definition in option argument.  If you\r\nwant to use the word in command line, use option directive instead.\r\n\r\n    define :kana: \\p{utf8::InKatakana}\r\n    option --kanalist --color=never -o --join --re ':kana:[:kana:\\n]+'\r\n    help   --kanalist List up Katakana string\r\n\r\nWhen _greple_ found `__CODE__` line in `.greplerc` file, the rest\r\nof the file is evaluated as a Perl program.  You can define your own\r\nsubroutines which can be used by __--inside__ and __--outside__ options.\r\nFor those subroutines, file content will be provided by global\r\nvariable `$_`.  Expected response from the subroutine is the list of\r\narray references, which is made up by start and end offset pairs.\r\n\r\nFor example, suppose that the following function is defined in your\r\n`.greplerc` file.\r\n\r\n    __CODE__\r\n    sub odd_line {\r\n        my @list;\r\n        my $i;\r\n        while (/.*\\n/g) {\r\n            push(@list, [ $-[0], $+[0] ]) if ++$i % 2;\r\n        }\r\n        @list;\r\n    }\r\n\r\nYou can use next command to search pattern included in odd number\r\nlines.\r\n\r\n    % greple --inside '&odd_line' patten files...\r\n\r\n\r\n\r\n# MODULE\r\n\r\nModules can be specified only at the beginning of command line by\r\n__-M___module_ option.  Name _module_ is prepended by __App::Greple__,\r\nso place the module file in `App/Greple/` directory in Perl library.\r\n\r\nIf the package name is declared properly, `__DATA__` section in the\r\nmodule file will be interpreted same as `.greplerc` file content.\r\n\r\nSee this sample module code.  This sample define options to search\r\nfrom pod, comment and other segment in Perl script.  Those capability\r\ncan be implemented both in function and macro.\r\n\r\n    package App::Greple::perl;\r\n    \r\n\r\n    BEGIN {\r\n        use Exporter   ();\r\n        our ($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS);\r\n    \r\n\r\n        $VERSION = sprintf \"%d.%03d\", q$Revision: 6.14 $ =~ /(\\d+)/g;\r\n    \r\n\r\n        @ISA         = qw(Exporter);\r\n        @EXPORT      = qw(&pod &comment &podcomment);\r\n        %EXPORT_TAGS = ( );\r\n        @EXPORT_OK   = qw();\r\n    }\r\n    our @EXPORT_OK;\r\n    \r\n\r\n    END { }\r\n    \r\n\r\n    my $pod_re = qr{^=\\w+(?s:.*?)(?:\\Z|^=cut\\s*\\n)}m;\r\n    my $comment_re = qr{^(?:[ \\t]*#.*\\n)+}m;\r\n    \r\n\r\n    sub pod {\r\n        my @list;\r\n        while (/$pod_re/g) {\r\n            push(@list, [ $-[0], $+[0] ] );\r\n        }\r\n        @list;\r\n    }\r\n    sub comment {\r\n        my @list;\r\n        while (/$comment_re/g) {\r\n            push(@list, [ $-[0], $+[0] ] );\r\n        }\r\n        @list;\r\n    }\r\n    sub podcomment {\r\n        my @list;\r\n        while (/$pod_re|$comment_re/g) {\r\n            push(@list, [ $-[0], $+[0] ] );\r\n        }\r\n        @list;\r\n    }\r\n    \r\n\r\n    1;\r\n    \r\n\r\n    __DATA__\r\n    \r\n\r\n    define :comment: ^(\\s*#.*\\n)+\r\n    define :pod: ^=(?s:.*?)(?:\\Z|^=cut\\s*\\n)\r\n    \r\n\r\n    #option --pod --inside :pod:\r\n    #option --comment --inside :comment:\r\n    #option --code --outside :pod:|:comment:\r\n    \r\n\r\n    option --pod --inside '&pod'\r\n    option --comment --inside '&comment'\r\n    option --code --outside '&podcomment'\r\n\r\nYou can use the module like this:\r\n\r\n    greple -Mperl --pod ...\r\n\r\n    greple -Mperl --code --comment --pod ...\r\n\r\n\r\n\r\n# HISTORY\r\n\r\nMost capability of __greple__ is derived from __mg__ command, which has\r\nbeen developing from early 1990's by the same author.  Because modern\r\nstandard __grep__ family command becomes to have similar capabilities,\r\nit is a time to clean up entire functionarities, totally remodel the\r\noption interfaces, and change the command name. (2013.11)\r\n\r\n# AUTHOR\r\n\r\nKazumasa Utashiro\r\n\r\n\r\n\r\n# SEE ALSO\r\n\r\n[grep(1)](http://man.he.net/man1/grep), [perl(1)](http://man.he.net/man1/perl)\r\n\r\n[github](http://kaz-utashiro.github.io/greple/)\r\n\r\n\r\n\r\n# LICENSE\r\n\r\nCopyright (c) 1991-2013 Kazumasa Utashiro\r\n\r\nUse and redistribution for ANY PURPOSE are granted as long as all\r\ncopyright notices are retained.  Redistribution with modification is\r\nallowed provided that you make your modified version obviously\r\ndistinguishable from the original one.  THIS SOFTWARE IS PROVIDED BY\r\nTHE AUTHOR ''AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES ARE\r\nDISCLAIMED.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}