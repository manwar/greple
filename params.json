{"name":"Greple","tagline":"greple: grep type command with multiple keywords","body":"# NAME\r\n\r\ngreple - grep with multiple keywords\r\n\r\n# SYNOPSIS\r\n\r\n**greple** \\[**-M**_module_\\] \\[ **-options** \\] pattern \\[ file... \\]\r\n\r\n    PATTERN\r\n      pattern              'positive +must -negative ?alternative'\r\n      -e pattern           regex pattern match across line boundary\r\n      -r pattern           regex pattern cannot be compromised\r\n      -v pattern           regex pattern not to be matched\r\n      --le pattern         lexical expression (same as bare pattern)\r\n      --re pattern         regular expression\r\n      --fe pattern         fixed expression\r\n      --file file          file contains search pattern\r\n    MATCH\r\n      -i                   ignore case\r\n      --need=[+-]n         required positive match count\r\n      --allow=[+-]n        acceptable negative match count\r\n    STYLE\r\n      -l                   list filename only\r\n      -c                   print count of matched block only\r\n      -n                   print line number\r\n      -h                   do not display filenames\r\n      -H                   always display filenames\r\n      -o                   print only the matching part\r\n      -A[n]                after match context\r\n      -B[n]                before match context\r\n      -C[n]                after and before match context\r\n      --join               delete newline in the matched part\r\n      --joinby=string      replace newline in the matched text by string\r\n      --filestyle=style    how filename printed (once, separate, line)\r\n      --linestyle=style    how line number printed (separate, line)\r\n      --separate           set filestyle and linestyle both \"separate\"\r\n    FILE\r\n      --glob=glob          glob target files\r\n      --chdir              change directory before search\r\n      --readlist           get filenames from stdin\r\n    COLOR\r\n      --color=when         use terminal color (auto, always, never)\r\n      --nocolor            same as --color=never\r\n      --colormap=color     R, G, B, C, M, Y, W, Standout, Double-struck, Underline\r\n      --colorful           use default multiple colors\r\n      --[no]256            use ANSI 256 colors\r\n      --regioncolor        use different color for inside/outside regions\r\n      --random             random color\r\n      --face\r\n    BLOCK\r\n      -p                   paragraph mode\r\n      --all                print whole data\r\n      --block=pattern      specify the block of records\r\n      --blockend=s         specify the block end mark (Default: \"--\\n\")\r\n    REGION\r\n      --inside=pattern     select matches inside of pattern\r\n      --outside=pattern    select matches outside of pattern\r\n      --include=pattern    reduce matches to the area\r\n      --exclude=pattern    reduce matches to outside of the area\r\n      --strict             strict mode for --inside/outside --block\r\n    CHARACTER CODE\r\n      --icode=name         specify file encoding\r\n      --ocode=name         specify output encoding\r\n    FILTER\r\n      --if=filter          set filter command\r\n      --of=filter          output filter command\r\n      --noif               disable default input filter\r\n    RUNTIME FUNCTION\r\n      --print=func         print function\r\n      --continue           continue after print function\r\n      --call=func          call function before search\r\n    PGP\r\n      --[no]pgp            decrypt and find PGP file (Default: false)\r\n      --pgppass=phrase     pgp passphrase\r\n    OTHER\r\n      --norc               skip reading startup file\r\n      --man                display command or module manual page\r\n      --show               display module file\r\n      -d flags             display info (f:file d:dir c:color m:misc s:stat)\r\n\r\n# DESCRIPTION\r\n\r\n## MULTIPLE KEYWORDS\r\n\r\n**greple** has almost the same function as Unix command [egrep(1)](http://man.he.net/man1/egrep) but\r\nthe search is done in the manner similar to search engine.  For\r\nexample, next command print lines those contain all of \\`foo' and \\`bar'\r\nand \\`baz'.\r\n\r\n    greple 'foo bar baz' ...\r\n\r\nEach word can be found in any order and/or any place in the string.\r\nSo this command find all of following texts.\r\n\r\n    foo bar baz\r\n    baz bar foo\r\n    the foo, bar and baz\r\n\r\nIf you want to use OR syntax, prepend question (\\`?') mark on each\r\ntoken, or use regular expression.\r\n\r\n    greple 'foo bar baz ?yabba ?dabba ?doo'\r\n    greple 'foo bar baz yabba|dabba|doo'\r\n\r\nThis command will print the line which contains all of \\`foo', \\`bar'\r\nand \\`baz' and one or more from \\`yabba', \\`dabba' or \\`doo'.\r\n\r\nNOT operator can be specified by prefixing the token by minus (\\`-')\r\nsign.  Next example will show the line which contain both \\`foo' and\r\nbar' but none of \\`yabba' or \\`dabba' or \\`doo'.\r\n\r\n    greple 'foo bar -yabba -dabba -doo'\r\n\r\nThis can be written as this using **-e** and **-v** option.\r\n\r\n    greple -e foo -e bar -v yabba -v dabba -v doo\r\n    greple -e foo -e bar -v 'yabba|dabba|doo'\r\n\r\nIf \\`+' is placed to positive matching pattern, that pattern is marked\r\nas required, and match required count is automatically set to the\r\nnumber of required pattern.  So\r\n\r\n    greple '+foo bar baz'\r\n\r\ncommands implicitly set the option `--need 1`, and consequently print\r\nall lines including \\`foo'.  If you want to search lines which includes\r\neither or both of \\`bar' and \\`baz', use like this:\r\n\r\n    greple '+foo bar baz' --need 2\r\n    greple '+foo bar baz' --need +1\r\n\r\n## LINE ACROSS MATCH\r\n\r\n**greple** also search the pattern across the line boundaries.  This is\r\nespecially useful to handle Asian multi-byte text.  Japanese text can\r\nbe separated by newline almost any place of the text.  So the search\r\npattern may spread out on multiple lines.\r\n\r\nAs for ascii text, space character in the pattern matches any kind of\r\nspace including newline.  Next example will search the word sequence\r\nof \\`foo', \\`bar' and 'baz', even they spread out to multiple lines.\r\n\r\n    greple -e 'foo bar baz'\r\n\r\nOption **-e** is necessary because space is taken as a token separator\r\nin the bare or **--le** pattern.\r\n\r\n# OPTIONS\r\n\r\n## PATTERNS\r\n\r\nIf specific option is not provided, **greple** takes the first argument\r\nas a search pattern specified by **-le** option.  All of these patterns\r\ncan be specified multiple times.\r\n\r\nCommand itself is written in Perl, and any kind of Perl style regular\r\nexpression can be used in patterns.  See [perlre(1)](http://man.he.net/man1/perlre) for detail.\r\n\r\nNote that multiple line modifier (`m`) is set when executed, so put\r\n`(?-m)` at the beginning of regex if you want to explicitly disable\r\nit.\r\n\r\nOrder of capture group in the pattern is not guaranteed.  Please avoid\r\nto use direct index, and use relative or named capture group instead.\r\nFor example, repated character can be written as `(\\w)\\g{-1}`\r\nor `(?<c>\\w)\\g{c}`.\r\n\r\n- **--le**=_pattern_\r\n\r\n    Treat the string as a collection of tokens separated by spaces.  Each\r\n    token is interpreted by the first character.  Token start with \\`-'\r\n    means negative pattern, \\`?' means alternative, and \\`+' does required.\r\n\r\n    Next example print lines which contains \\`foo' and \\`bar', and one or\r\n    more of \\`yabba' and 'dabba', and none of \\`bar' and \\`doo'.\r\n\r\n        greple --le='foo bar -baz ?yabba ?dabba -doo'\r\n\r\n    Multiple \\`?' preceded tokens are treated all mixed together.  That\r\n    means \\`?A|B ?C|D' is equivalent to \\`?A|B|C|D'.  If you want to mean\r\n    \\`(A or B) and (C or D)', use AND syntax instead: \\`A|B C|D'.\r\n\r\n    If the pattern start with ampersand (\\`&'), it is treated as a\r\n    function, and the function is called instead of searching pattern.\r\n    Function call interface is same as the one for block/region options.\r\n\r\n    If you have a definition of _odd\\_line_ function in you `.greplrc`,\r\n    which is described in this manual later, you can print odd number\r\n    lines like this:\r\n\r\n        greple -n '&odd_line' file\r\n\r\n    This is the summary of start character for **--le** option:\r\n\r\n        +  Required pattern\r\n        -  Negative match pattern\r\n        ?  Alternative pattern\r\n        &  Function call\r\n\r\n- **-e** _pattern_, **--and**=_pattern_\r\n\r\n    Specify positive match token.  Next two commands are equivalent.\r\n\r\n        greple 'foo bar baz'\r\n        greple -e foo -e bar -e baz\r\n\r\n    First character is not interpreted, so next commands will search the\r\n    pattern \\`-baz'.\r\n\r\n        greple -e -baz\r\n\r\n    Space characters are treated specially by **-e** and **-v** options.\r\n    They are replaced by the pattern which matches any number of\r\n    white spaces including newline.  So the pattern can be expand to\r\n    multiple lines.  Next commands search the series of word \\`foo', \\`bar'\r\n    and \\`baz' even if they are separated by newlines.\r\n\r\n        greple -e 'foo bar baz'\r\n\r\n- **-r** _pattern_, **--must**=_pattern_\r\n\r\n    Specify required match token.  Next two commands are equivalent.\r\n\r\n        greple '+foo bar baz'\r\n        greple -r foo -e bar -e baz\r\n\r\n- **-v** _pattern_, **--not**=_pattern_\r\n\r\n    Specify negative match token.  Because it does not affect to the bare\r\n    pattern argument, you can narrow down the search result like this.\r\n\r\n        greple foo pattern file\r\n        greple foo pattern file -v bar\r\n        greple foo pattern file -v bar -v baz\r\n\r\n- **--re**=_pattern_\r\n\r\n    Specify regular expression.  No special treatment for space and wide\r\n    characters.\r\n\r\n- **--fe**=_pattern_\r\n\r\n    Specify fixed string pattern, like fgrep.\r\n\r\n- **-i**, **--ignore-case**\r\n\r\n    Ignore case.\r\n\r\n- **--need**=_n_\r\n- **--allow**=_n_\r\n\r\n    Option to compromize matching condition.  Option **--need** specifies\r\n    the required match count, and **--allow** the number of negative\r\n    condition to be overlooked.\r\n\r\n        greple --need=2 --allow=1 'foo bar baz -yabba -dabba -doo'\r\n\r\n    Above command prints the line which contains two or more from \\`foo',\r\n    \\`bar' and \\`baz', and does not include more than one of \\`yabba',\r\n    \\`dabba' or \\`doo'.\r\n\r\n    Using option **--need**=_1_, **greple** produces same result as **grep**\r\n    command.\r\n\r\n        grep -e foo -e bar -e baz\r\n        greple --need=1 -e foo -e bar -e baz\r\n\r\n    When the count _n_ is negative value, it is subtracted from default\r\n    value.\r\n\r\n- **-f** _file_, **--file**=_file_\r\n\r\n    Specify the file which contains search pattern.  When file contains\r\n    multiple lines, patterns on each lines are search in OR context.\r\n\r\n    Blank line and the line starting with sharp (#) character is ignored.\r\n    Two slashes (//) and following string are taken as a comment and\r\n    removed with preceding spaces.\r\n\r\n    Multiple file can be specified, but they will be mixed into single\r\n    pattern.\r\n\r\n## STYLES\r\n\r\n- **-l**\r\n\r\n    List filename only.\r\n\r\n- **-c**, **--count**\r\n\r\n    Print count of matched block.\r\n\r\n- **-n**, **--line-number**\r\n\r\n    Show line number.\r\n\r\n- **-h**, **--no-filename**\r\n\r\n    Do not display filename.\r\n\r\n- **-H**\r\n\r\n    Display filename always.\r\n\r\n- **-o**\r\n\r\n    Print matched string only.\r\n\r\n- **-A**\\[_n_\\], **--after-context**\\[=_n_\\]\r\n- **-B**\\[_n_\\], **--before-context**\\[=_n_\\]\r\n- **-C**\\[_n_\\], **--context**\\[=_n_\\]\r\n\r\n    Print _n_-blocks before/after matched string.  The value _n_ can be\r\n    omitted and the default is 2.  When used with **--paragraph** or\r\n    **--block** option, _n_ means number of paragraph or block.\r\n\r\n    Actually, these options expand the area of logical operation.  It\r\n    means\r\n\r\n        grep -C1 'foo bar baz'\r\n\r\n    matches following text.\r\n\r\n        foo\r\n        bar\r\n        baz\r\n\r\n    Moreover\r\n\r\n        greple -C1 'foo baz'\r\n\r\n    also matches this text, because matching blocks around \\`foo' and \\`bar'\r\n    overlaps each other and makes single block.\r\n\r\n- **--join**\r\n- **--joinby**=_string_\r\n\r\n    Convert newline character found in matched string to empty or specifed\r\n    _string_.  Using **--join** with **-o** (only-matching) option, you can\r\n    collect searching sentence list in one per line form.  This is\r\n    sometimes useful for Japanese text processing.  For example, next\r\n    command prints the list of KATAKANA words, including those spread\r\n    across multiple lines.\r\n\r\n        greple -ho --join '\\p{InKatakana}+(\\n\\p{InKatakana}+)*'\r\n\r\n    Space separated word sequence can be processed with **--joinby**\r\n    option.  Next exapmle prints all \\`for \\*something\\*' pattern in pod\r\n    documents within Perl script.\r\n\r\n        greple -Mperl --pod -ioe '\\bfor \\w+' --joinby ' '\r\n\r\n- **--filestyle**=_line_|_once_|_separate_, **--fs**\r\n\r\n    Default style is _line_, and **greple** prints filename at the\r\n    beginning of each line.  Style _once_ prints the filename only once\r\n    at the first time.  Style _separate_ prints filename in the separate\r\n    line before each line or block.\r\n\r\n- **--linestyle**=_line_|_separate_, **--ls**\r\n\r\n    Default style is _line_, and **greple** prints line numbers at the\r\n    beginning of each line.  Style _separate_ prints line number in the\r\n    separate line before each line or block.\r\n\r\n- **--separate**\r\n\r\n    Shortcut for **--filestyle**=_separate_ **--linestyle**=_separate_.\r\n    This is convenient to use block mode search and visiting each location\r\n    from supporting tool, such as Emacs.\r\n\r\n## FILES\r\n\r\n- **--glob**=_pattern_\r\n\r\n    Get files matches to specified pattern and use them as a target files.\r\n    Using **--chdir** and **--glob** makes easy to use **greple** for fixed\r\n    common job.\r\n\r\n- **--chdir**=_directory_\r\n\r\n    Change directory before processing files.  When multiple directories\r\n    are specified in **--chdir** option, by using wildcard form or\r\n    repeating option, **--glob** file expantion will be done for every\r\n    directories.\r\n\r\n        greple --chdir '/usr/man/man?' --glob '*.[0-9]' ...\r\n\r\n- **--readlist**\r\n\r\n    Get filenames from standard input.  Read standard input and use each\r\n    line as a filename for searching.  You can feed the output from other\r\n    command like [find(1)](http://man.he.net/man1/find) for **greple** with this option.  Next example\r\n    searches string from files modified within 7 days:\r\n\r\n        find . -mtime -7 -print | greple --readlist pattern\r\n\r\n## COLORS\r\n\r\n- **--color**=_auto_|_always_|_never_, **--nocolor**\r\n\r\n    Use terminal color capability to emphasize the matched text.  Default\r\n    is \\`auto': effective when STDOUT is a terminal and option **-o** is not\r\n    given, not otherwise.  Option value \\`always' and \\`never' will work as\r\n    expected.\r\n\r\n    Option **--nocolor** is alias for **--color**=_never_.\r\n\r\n- **--colormap**=_RGBCYMKWrgbcymkwSUDF_, **--quote**=_start_,_end_\r\n\r\n    Specify color map.  Default is RD: RED and BOLD.\r\n\r\n    COLOR is combination of single character representing uppercase\r\n    foreground color :\r\n\r\n        R  Red\r\n        G  Green\r\n        B  Blue\r\n        C  Cyan\r\n        M  Magenta\r\n        Y  Yellow\r\n        K  Black\r\n        W  White\r\n\r\n    and corresponding lowercase background color :\r\n\r\n        r, g, b, c, m, y, k, w\r\n\r\n    or RGB value if using ANSI 256 color terminal :\r\n\r\n        FORMAT:\r\n            foreground[/background]\r\n\r\n        COLOR:\r\n            000 .. 555       : 6 x 6 x 6 216 colors\r\n            000000 .. FFFFFF : 24bit RGB mapped to 216 colors\r\n\r\n        Sample:\r\n            005     0000FF        : blue foreground\r\n               /505       /FF00FF : magenta background\r\n            000/555 000000/FFFFFF : black on white\r\n            500/050 FF0000/00FF00 : red on green\r\n\r\n    and other effects :\r\n\r\n        S  Standout (reverse video)\r\n        U  Underline\r\n        D  Double-struck (boldface)\r\n        F  Flash (blink)\r\n\r\n    If the mode string contains colon \\`:' character, they are used to\r\n    quote the matched string.  If you want to quote the pattern by angle\r\n    bracket, use like this.\r\n\r\n        greple --quote='<:>' pattern\r\n\r\n    Option **--quote** is an alias for **--colormap**, but it set the\r\n    option **--color**=_always_ at the same time.\r\n\r\n    Multiple colors can be specified separating by white space or comma,\r\n    or by repeating options.  Those colors will be applied for each\r\n    pattern keywords.  Next command will show word \\`foo' in red, \\`bar' in\r\n    green and \\`baz' in blue.\r\n\r\n        greple --colormap='R G B' 'foo bar baz'\r\n\r\n        greple --cm R -e foo --cm G -e bar --cm B -e baz\r\n\r\n- **--colormap**=_field_=_color_,_field_=_color_,...\r\n\r\n    Another form of colormap option to specify the color for fields:\r\n\r\n        FILE      File name\r\n        LINE      Line number\r\n        BLOCKEND  Block end mark\r\n\r\n- **--\\[no\\]colorful**\r\n\r\n    Shortcut for **--colormap**='_RD GD BD CD MD YD_' in ANSI 16 colors\r\n    mode, and **--colormap**='_D/544 D/454 D/445 D/455 D/454 D/554_' and\r\n    other combination of 3, 4, 5 for 256 colors mode.  Enabled by default.\r\n\r\n- **--\\[no\\]256**\r\n\r\n    Set/unset ANSI 256 color mode.  Enabled by default.\r\n\r\n- **--regioncolor**\r\n\r\n    Use different colors for each **--inside**/**outside** regions.\r\n    Disabled by default.\r\n\r\n- **--face**=\\[-+\\]_effect_\r\n\r\n    Set or unset specified _effect_ for all color specs.  Use \\`+'\r\n    (optional) to set, and \\`-' to unset.  Effect is a single character\r\n    expressing: S (Standout), U (Underline), D (Double-struck), F (Flash).\r\n\r\n    Next example romove D (double-struck) effect.\r\n\r\n        greple --face -D\r\n\r\n    Multiple effects can be set/unset at once.\r\n\r\n        greple --face SF-D\r\n\r\n## BLOCKS\r\n\r\n- **-p**, **--paragraph**\r\n\r\n    Print the paragraph which contains the pattern.  Each paragraph is\r\n    delimited by two or more successive newline characters by default.  Be\r\n    aware that an empty line is not paragraph delimiter if which contains\r\n    space characters.  Example:\r\n\r\n        greple -np 'setuid script' /usr/man/catl/perl.l\r\n\r\n        greple -pe '^struct sockaddr' /usr/include/sys/socket.h\r\n\r\n    It changes the unit of context specified by **-A**, **-B**, **-C**\r\n    options.\r\n\r\n- **--all**\r\n\r\n    Treat entire file contents as a single block.  This is almost\r\n    identical to following command.\r\n\r\n        greple --block='(?s).*'\r\n\r\n- **--block**=_pattern_, **--block**=_&sub_\r\n\r\n    Specify the record block to display.  Default block is a single line.\r\n\r\n    Next example behave almost same as **--paragraph** option, but is less\r\n    efficient.\r\n\r\n        greple --block='(.+\\n)+'\r\n\r\n    Next command treat the data as a series of 10-line blocks.\r\n\r\n        greple -n --block='(.*\\n){1,10}'\r\n\r\n    When blocks are not continuous and there are gaps between them, the\r\n    match occurred outside blocks are ignored.\r\n\r\n    If multiple block options are supplied, overlapping blocks are merged\r\n    into single block.\r\n\r\n    Please be aware that this option is sometimes quite time consuming,\r\n    because it finds all blocks before processing.\r\n\r\n- **--blockend**=_string_\r\n\r\n    Change the end mark displayed after **-pABC** or **--block** options.\r\n    Default value is \"--\\\\n\".\r\n\r\n## REGIONS\r\n\r\n- **--inside**=_pattern_\r\n- **--outside**=_pattern_\r\n\r\n    Option **--inside** and **--outside** limit the text area to be matched.\r\n    For simple example, if you want to find string \\`and' not in the word\r\n    \\`command', it can be done like this.\r\n\r\n        greple --outside=command and\r\n\r\n    The block can be larger and expand to multiple lines.  Next command\r\n    searches from C source, excluding comment part.\r\n\r\n        greple --outside '(?s)/\\*.*?\\*/'\r\n\r\n    Next command searches only from POD part of the perl script.\r\n\r\n        greple --inside='(?s)^=.*?(^=cut|\\Z)'\r\n\r\n    When multiple **inside** and **outside** regions are specified, those\r\n    regions are mixed up in union way.\r\n\r\n    In multiple color environment, and if single keyword is specified,\r\n    matches in each **--inside**/**outside** regions are printed in\r\n    different colors.  Forcing this operation with multiple keywords, use\r\n    **--regioncolor** option.\r\n\r\n- **--inside**=_&function_\r\n- **--outside**=_&function_\r\n\r\n    If the pattern name begins by ampersand (&) character, it is treated\r\n    as a name of subroutine which returns a list of blocks.  Using this\r\n    option, user can use arbitrary function to determine from what part of\r\n    the text they want to search.  User defined function can be defined in\r\n    `.greplerc` file or by module option.\r\n\r\n- **--include**=_pattern_\r\n- **--exclude**=_pattern_\r\n- **--include**=_&function_\r\n- **--exclude**=_&function_\r\n\r\n    **--include**/**exclude** option behave exactly same as\r\n    **--inside**/**outside** when used alone.\r\n\r\n    When used in combination, **--include**/**exclude** are mixed in AND\r\n    manner, while **--inside**/**outside** are in OR.\r\n\r\n    Thus, in the next example, first line prints all matches, and second\r\n    does none.\r\n\r\n        greple --inside PATTERN --outside PATTERN\r\n\r\n        greple --include PATTERN --exclude PATTERN\r\n\r\n    You can make up desired matches using **--inside**/**outside** option,\r\n    then remove unnecessary part by **--include**/**exclude**\r\n\r\n- **--strict**\r\n\r\n    Limit the match area strictly.\r\n\r\n    By default, **--block**, **--inside**/**outside**,\r\n    **--include**/**exclude** option allows partial match within the\r\n    specified area.  For instance,\r\n\r\n        greple --inside and command\r\n\r\n    matches pattern `command` because the part of matched string is\r\n    included in specified inside-area.  Partial match failes when option\r\n    **--strict** provided, and longer string never matches within shorter\r\n    area.\r\n\r\n## CHARACTER CODE\r\n\r\n- **--icode**=_code_\r\n\r\n    Target file is assumed to be encoded in utf8 by default.  Use this\r\n    option to set specific encoding.  When handling Japanese text, you may\r\n    choose from 7bit-jis (jis), euc-jp or shiftjis (sjis).  Multiple code\r\n    can be supplied using multiple option or combined code names with\r\n    space or comma, then file encoding is guessed from those code sets.\r\n    Use encoding name \\`guess' for automatic recognition from default code\r\n    list which is euc-jp and 7bit-jis.  Following commands are all\r\n    equivalent.\r\n\r\n        greple --icode=guess ...\r\n        greple --icode=euc-jp,7bit-jis ...\r\n        greple --icode=euc-jp --icode=7bit-jis ...\r\n\r\n    Default code set are always included suspect code list.  If you have\r\n    just one code adding to suspect list, put + mark before the code name.\r\n    Next example does automatic code detection from euc-kr, ascii, utf8\r\n    and UTF-16/32.\r\n\r\n        greple --icode=+euc-kr ...\r\n\r\n- **--ocode**=_code_\r\n\r\n    Specify output code.  Default is utf8.\r\n\r\n## FILTER\r\n\r\n- **--if**=_filter_, **--if**=_EXP_:_filter_:_EXP_:_filter_:...\r\n\r\n    You can specify filter command which is applied to each files before\r\n    search.  If only one filter command is specified, it is applied to all\r\n    files.  If filter information include multiple fields separated by\r\n    colons, first field will be perl expression to check the filename\r\n    saved in variable $\\_.  If it successes, next filter command is pushed.\r\n    These expression and command list can be repeated.\r\n\r\n        greple --if=rev perg\r\n        greple --if='/\\.tar$/:tar tvf -'\r\n\r\n    If the command doesn't accept standard input as processing data, you\r\n    may be able to use special device:\r\n\r\n        greple --if='nm /dev/stdin' crypt /usr/lib/lib*\r\n\r\n    Filters for compressed and gzipped file is set by default unless\r\n    **--noif** option is given.  Default action is like this:\r\n\r\n        greple --if='s/\\.Z$//:zcat:s/\\.g?z$//:gunzip -c'\r\n\r\n- **--noif**\r\n\r\n    Disable default input filter.  Which means compressed files will not\r\n    be decompressed automatically.\r\n\r\n- **--of**=_filter_\r\n\r\n    Specify output filter commands.\r\n\r\n## RUNTIME FUNCTIONS\r\n\r\n- **--print**=_function_, **--print**=_sub{...}_\r\n\r\n    Specify user defined function executed before data print.  Text to be\r\n    printed is replaced by the result of the funcion.  Arbitrary function\r\n    can be defined in `.greplerc` file.  Matched data is placed in\r\n    variable `$_`.  Other information is passed by key-value pair in the\r\n    arguments.  Filename is passed by `file` key.  Matched informaiton is\r\n    passed by `matched` key, in the form of perl array reference:\r\n    `[[start,end],[start,end]...]`.\r\n\r\n    Simplest function is **--print**='_sub{$\\_}_'.  Coloring capability can\r\n    be used like this:\r\n\r\n        # ~/.greplerc\r\n        __CODE__\r\n        sub print_simple {\r\n            my %attr = @_;\r\n            for my $r (reverse @{$attr{matched}}) {\r\n                my($s, $e) = @$r;\r\n                substr($_, $s, $e - $s, color('B', substr($_, $s, $e - $s)));\r\n            }\r\n            $_;\r\n        }\r\n\r\n    Then, you can use this function in the command line.\r\n\r\n        greple --print=print_simple ...\r\n\r\n    It is possible to use multiple **--print** options.  In that case,\r\n    second function will get the result of the first function.  The\r\n    command will print the final result of the last funciton.\r\n\r\n- **--continue**\r\n\r\n    When **--print** option is given, **greple** will immediately print the\r\n    result returned from print function and finish the cycle.  Option\r\n    **--continue** forces to continue normal printing process after print\r\n    function called.  So please be sure that all data being consistent.\r\n\r\n- **--call**=_function_(_..._), **--call**=_function_=_..._\r\n- **-M**_module_::_function(...)_, **-M**_module_::_function=..._\r\n\r\n    Option **--call** specify the function executed at the beginning of\r\n    each file processing.  This _function_ have to be called from **main**\r\n    package.  So if you define the function in the module package, use the\r\n    full package name or export properly.\r\n\r\n    It can be set with module option, following module name.  In this\r\n    form, the function will be called with module package name.  So you\r\n    don't have to export it.\r\n\r\nFor these run-time functions, optional argument list can be set in the\r\nform of `key` or `key=value`, connected by comma.  These arguments\r\nwill be passed to the funciton in key => value list.  Sole key will\r\nhave the value one.  Also processing file name is passed with \"file\"\r\nkey.  As a result, the option in the next form:\r\n\r\n    --print|call function(key1,key=val2)\r\n    --print|call function=key1,key=val2\r\n\r\n    -Mmodule::function(key1,key=val2)\r\n    -Mmodule::function=key1,key=val2\r\n\r\nwill be transformed into following function call:\r\n\r\n    function(file => \"filename\", key1 => 1, key2 => \"val2\")\r\n\r\nThe function can be defined in `.greplerc` or modules.  Assign the\r\narguments into hash, then you can access argument list as member of\r\nthe hash.  Content of the target file can be accessed by `$_`.\r\n\r\n    sub function {\r\n        my %arg = @_;\r\n        $arg{file};    # \"filename\"\r\n        $arg{key1};    # 1\r\n        $arg{key2};    # \"val2\"\r\n        $_;            # contents\r\n    }\r\n\r\n## PGP\r\n\r\n- **--pgp**\r\n\r\n    Invoke PGP decrypt command for files end with _.pgp_, _.gpg_ or\r\n    _.asc_.  PGP passphrase is asked only once at the beginning of\r\n    command execution.\r\n\r\n- **--pgppass**=_phrase_\r\n\r\n    You can specify PGP passphrase by this option.  Generally, it is not\r\n    recommended to use.\r\n\r\n## OTHERS\r\n\r\n- **--norc**\r\n\r\n    Do not read startup file: `~/.greplerc`.\r\n\r\n- **--man**\r\n\r\n    Show manual page.\r\n    Display module's manual page when used with **-M** option.\r\n\r\n- **--show**\r\n\r\n    Show module file contents.  Use with **-M** option.\r\n\r\n- **--require**=_filename_\r\n\r\n    Include arbitrary perl program.\r\n\r\n# ENVIRONMENT and STARTUP FILE\r\n\r\nEnvironment variable GREPLEOPTS is used as a default options.  They\r\nare inserted before command line options.\r\n\r\nBefore starting execution, _greple_ reads the file named `.greplerc`\r\non user's home directory.  Following directives can be used.\r\n\r\n- **option** _name_ string\r\n\r\n    Argument _name_ of \\`option' directive is user defined option name.\r\n    The rest are processed by _shellwords_ routine defined in\r\n    Text::ParseWords module.  Be sure that this module sometimes requires\r\n    escape backslashes.\r\n\r\n    Any kind of string can be used for option name but it is not combined\r\n    with other options.\r\n\r\n        option --fromcode --outside='(?s)\\/\\*.*?\\*\\/'\r\n        option --fromcomment --inside='(?s)\\/\\*.*?\\*\\/'\r\n\r\n    If the option named **default** is defined, it will be used as a\r\n    default option.\r\n\r\n    For the purpose to include following arguments within replaced\r\n    strings, two special notations can be used in option definition.\r\n    String `$<_n_>` is replaced by the _n_th argument after the\r\n    substituted option, where _n_ is number start from one.  String\r\n    `$<shift>` is replaced by following command line argument and\r\n    the argument is removed from option list.\r\n\r\n    For example, when\r\n\r\n        option --line --le &line=$<shift>\r\n\r\n    is defined, command\r\n\r\n        greple --line 10,20-30,40\r\n\r\n    will be evaluated as this:\r\n\r\n        greple --le &line=10,20-30,40\r\n\r\n- **help** _name_\r\n\r\n    If \\`help' directive is used for same option name, it will be printed\r\n    in usage message.  If the help message is \\`ignore', corresponding line\r\n    won't show up in the usage.\r\n\r\n- **define** _name_ string\r\n\r\n    Directive \\`define' is almost same as \\`option', but argument is not\r\n    processed by _shellwords_ and treated just a simple text.\r\n    Metacharacters can be included without escaping.  Defined string\r\n    replacement is done only in definition in option argument.  If you\r\n    want to use the word in command line, use option directive instead.\r\n\r\n        define :kana: \\p{InKatakana}\r\n        option --kanalist --nocolor -o --join --re ':kana:+(\\n:kana:+)*'\r\n        help   --kanalist List up Katakana string\r\n\r\nEnvironment variable substitution is done for string specified by\r\n\\`option' and \\`define' directivies.  Use Perl syntax **$ENV{NAME}** for\r\nthis purpose.  You can use this to make a portable module.\r\n\r\nWhen _greple_ found `__CODE__` line in `.greplerc` file, the rest\r\nof the file is evaluated as a Perl program.  You can define your own\r\nsubroutines which can be used by **--inside**/**outside**,\r\n**--include**/**exclude**, **--block** options.\r\n\r\nFor those subroutines, file content will be provided by global\r\nvariable `$_`.  Expected response from the subroutine is the list of\r\narray references, which is made up by start and end offset pairs.\r\n\r\nFor example, suppose that the following function is defined in your\r\n`.greplerc` file.  Start and end offset for each pattern match can be\r\ntaken as array element `$-[0]` and `$+[0]`.\r\n\r\n    __CODE__\r\n    sub odd_line {\r\n        my @list;\r\n        my $i;\r\n        while (/.*\\n/g) {\r\n            push(@list, [ $-[0], $+[0] ]) if ++$i % 2;\r\n        }\r\n        @list;\r\n    }\r\n\r\nYou can use next command to search pattern included in odd number\r\nlines.\r\n\r\n    % greple --inside '&odd_line' patten files...\r\n\r\n# MODULE\r\n\r\nModules can be specified only at the beginning of command line by\r\n**-M**_module_ option.  Name _module_ is prepended by **App::Greple**,\r\nso place the module file in `App/Greple/` directory in Perl library.\r\n\r\nIf the package name is declared properly, `__DATA__` section in the\r\nmodule file will be interpreted same as `.greplerc` file content.\r\n\r\nUsing **-M** without module argument will print available module list.\r\nOption **--man** will display module document when used with **-M**\r\noption.  Use **--show** option to see the module itself.\r\n\r\nSee this sample module code.  This sample define options to search\r\nfrom pod, comment and other segment in Perl script.  Those capability\r\ncan be implemented both in function and macro.\r\n\r\n    package App::Greple::perl;\r\n    \r\n    BEGIN {\r\n        use Exporter   ();\r\n        our ($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS);\r\n    \r\n        $VERSION = sprintf \"%d.%03d\", q$Revision: 6.22 $ =~ /(\\d+)/g;\r\n    \r\n        @ISA         = qw(Exporter);\r\n        @EXPORT      = qw(&pod &comment &podcomment);\r\n        %EXPORT_TAGS = ( );\r\n        @EXPORT_OK   = qw();\r\n    }\r\n    our @EXPORT_OK;\r\n    \r\n    END { }\r\n    \r\n    my $pod_re = qr{^=\\w+(?s:.*?)(?:\\Z|^=cut\\s*\\n)}m;\r\n    my $comment_re = qr{^(?:[ \\t]*#.*\\n)+}m;\r\n    \r\n    sub pod {\r\n        my @list;\r\n        while (/$pod_re/g) {\r\n            push(@list, [ $-[0], $+[0] ] );\r\n        }\r\n        @list;\r\n    }\r\n    sub comment {\r\n        my @list;\r\n        while (/$comment_re/g) {\r\n            push(@list, [ $-[0], $+[0] ] );\r\n        }\r\n        @list;\r\n    }\r\n    sub podcomment {\r\n        my @list;\r\n        while (/$pod_re|$comment_re/g) {\r\n            push(@list, [ $-[0], $+[0] ] );\r\n        }\r\n        @list;\r\n    }\r\n    \r\n    1;\r\n    \r\n    __DATA__\r\n    \r\n    define :comment: ^(\\s*#.*\\n)+\r\n    define :pod: ^=(?s:.*?)(?:\\Z|^=cut\\s*\\n)\r\n    \r\n    #option --pod --inside :pod:\r\n    #option --comment --inside :comment:\r\n    #option --code --outside :pod:|:comment:\r\n    \r\n    option --pod --inside '&pod'\r\n    option --comment --inside '&comment'\r\n    option --code --outside '&podcomment'\r\n\r\nYou can use the module like this:\r\n\r\n    greple -Mperl --pod default greple\r\n\r\n    greple -Mperl --colorful --code --comment --pod default greple\r\n\r\n# HISTORY\r\n\r\nMost capability of **greple** is derived from **mg** command, which has\r\nbeen developing from early 1990's by the same author.  Because modern\r\nstandard **grep** family command becomes to have similar capabilities,\r\nit is a time to clean up entire functionarities, totally remodel the\r\noption interfaces, and change the command name. (2013.11)\r\n\r\n# AUTHOR\r\n\r\nKazumasa Utashiro\r\n\r\n# SEE ALSO\r\n\r\n[grep(1)](http://man.he.net/man1/grep), [perl(1)](http://man.he.net/man1/perl)\r\n\r\n[github](http://kaz-utashiro.github.io/greple/)\r\n\r\n# LICENSE\r\n\r\nCopyright (c) 1991-2014 Kazumasa Utashiro\r\n\r\nUse and redistribution for ANY PURPOSE are granted as long as all\r\ncopyright notices are retained.  Redistribution with modification is\r\nallowed provided that you make your modified version obviously\r\ndistinguishable from the original one.  THIS SOFTWARE IS PROVIDED BY\r\nTHE AUTHOR \\`\\`AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES ARE\r\nDISCLAIMED.\r\n","google":"UA-47549010-1","note":"Don't delete this file! It's used internally to help with page regeneration."}