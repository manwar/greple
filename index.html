<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Greple by kaz-utashiro</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="javascripts/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1 class="header">Greple</h1>
        <p class="header">greple: grep type command with multiple keywords</p>

        <ul>
          <li class="download"><a class="buttons" href="https://github.com/kaz-utashiro/greple/zipball/master">Download ZIP</a></li>
          <li class="download"><a class="buttons" href="https://github.com/kaz-utashiro/greple/tarball/master">Download TAR</a></li>
          <li><a class="buttons github" href="https://github.com/kaz-utashiro/greple">View On GitHub</a></li>
        </ul>

        <p class="header">This project is maintained by <a class="header name" href="https://github.com/kaz-utashiro">kaz-utashiro</a></p>


      </header>
      <section>
        <h1>
<a name="name" class="anchor" href="#name"><span class="octicon octicon-link"></span></a>NAME</h1>

<p>greple - grep with multiple keywords</p>

<h1>
<a name="synopsis" class="anchor" href="#synopsis"><span class="octicon octicon-link"></span></a>SYNOPSIS</h1>

<p><strong>greple</strong> [<strong>-M</strong>_module_] [ <strong>-options</strong> ] pattern [ file... ]</p>

<pre><code>pattern           'positive -negative ?alternative'

-e pattern        regex pattern match across line boundary
-v pattern        regex pattern not to be matched
--le pattern      lexical expression (same as bare pattern)
--re pattern      regular expression
--fe pattern      fixed expression
</code></pre>

<h2>
<a name="options" class="anchor" href="#options"><span class="octicon octicon-link"></span></a><strong>OPTIONS</strong>
</h2>

<pre><code>-i                   ignore case
-l                   list filename only
-c                   print count of matched block only
-n                   print line number
-h                   do not display filenames
-H                   always display filenames
--inside=pattern     limit matching area
--outside=pattern    opposite to --inside
--revinside=pattern  inside reverse pattern
--revoutside=pattern outside reverse pattern
--strict             strict mode for --inside/outside --block
--join               delete newline in the matched part
--joinby=string      replace newline in the matched text by string

--need=n             required positive match count
--allow=n            acceptable negative match count

--color=when         use terminal color (auto, always, never)
--nocolor            same as --color=never
--colormode=mode     R, G, B, C, M, Y, W, Standout, bolD, Underline
--colorful           same as --colormode 'RD GD BD CD MD YD'
--random             random color
--regioncolor        color by region

-o                   print only the matching part
-p                   paragraph mode
-A[n]                after match context
-B[n]                before match context
-C[n]                after and before match context
--all                print whole data
--block=pattern      specify the block of records
--blockend=s         specify the block end mark (Default: "--\n")

-f file              file contains search pattern
-d flags             display info (f:file d:dir c:count m:misc s:stat)
--man                show manual page
--icode=name         specify file encoding
--ocode=name         specify output encoding
--if=filter          set filter command
--of=filter          output filter command
--[no]pgp            decrypt and find PGP file (Default: false)
--pgppass=phrase     pgp passphrase
--[no]decompress     process compressed data (Default: true)
--readlist           get filenames from stdin
--chdir              change directory before search
--glob=glob          glob target files
--print=func         print function
--continue           continue after print function
--norc               skip reading startup file
</code></pre>

<h1>
<a name="description" class="anchor" href="#description"><span class="octicon octicon-link"></span></a>DESCRIPTION</h1>

<p><strong>greple</strong> has almost the same function as Unix command <a href="http://man.he.net/man1/egrep">egrep(1)</a> but
the search is done in the manner similar to search engine.  For
example, next command print lines those contain all of 'foo' and 'bar'
and 'baz'.</p>

<pre><code>greple 'foo bar baz' ...
</code></pre>

<p>Each word can be found in any order and/or any place in the string.
So this command find all of following texts.</p>

<pre><code>foo bar baz
baz bar foo
the foo, bar and baz
</code></pre>

<p>If you want to use OR syntax, prepend question ('?') mark on each
token, or use regular expression.</p>

<pre><code>greple 'foo bar baz ?yabba ?dabba ?doo'
greple 'foo bar baz yabba|dabba|doo'
</code></pre>

<p>This command will print the line which contains all of 'foo', 'bar'
and 'baz' and one or more from 'yabba', 'dabba' or 'doo'.</p>

<p>NOT operator can be specified by prefixing the token by minus ('-')
sign.  Next example will show the line which contain both 'foo' and
bar' but none of 'yabba' or 'dabba' or 'doo'.  It is ok to put '+'
mark for positive matching pattern.</p>

<pre><code>greple 'foo bar -yabba -dabba -doo'
greple '+foo +bar -yabba|dabba|doo'
</code></pre>

<p>This can be written as this using <strong>-e</strong> and <strong>-v</strong> option.</p>

<pre><code>greple -e foo -e bar -v yabba -v dabba -v doo
greple -e foo -e bar -v 'yabba|dabba|doo'
</code></pre>

<h2>
<a name="line-across-match" class="anchor" href="#line-across-match"><span class="octicon octicon-link"></span></a><strong>LINE ACROSS MATCH</strong>
</h2>

<p><strong>greple</strong> also search the pattern across the line boundaries.  This is
especially useful to handle Asian multi-byte text.  Japanese text can
be separated by newline almost any place of the text.  So the search
pattern may spread out on multiple lines.  As for ascii text, space
character in the pattern matches any kind of space including newline.
Use <strong>-e</strong> option to use this capability because space is taken as a
token separator in the bare pattern.</p>

<h1>
<a name="options-1" class="anchor" href="#options-1"><span class="octicon octicon-link"></span></a>OPTIONS</h1>

<h2>
<a name="patterns" class="anchor" href="#patterns"><span class="octicon octicon-link"></span></a><strong>PATTERNS</strong>
</h2>

<p>If specific option is not provided, <strong>greple</strong> takes the first argument
as a search pattern specified by <strong>-le</strong> option.  All of these patterns
can be specified multiple times.</p>

<p>Command itself is written in Perl, and any kind of Perl style regular
expression can be used in patterns.</p>

<h4>
<a name="--lepattern" class="anchor" href="#--lepattern"><span class="octicon octicon-link"></span></a><strong>--le</strong>=<em>pattern</em>
</h4>

<p>Treat the string as a collection of tokens separated by spaces.  Each
token is interpreted by the first character.  Token start with '-'
means negative pattern, '?' means alternative, optional '+' and
anything other means positive match.</p>

<p>Next example print lines which contains 'foo' and 'bar', and one or
more of 'yabba' and 'dabba', and none of 'bar' and 'doo'.</p>

<pre><code>greple --le='foo bar -baz ?yabba ?dabba -doo'
</code></pre>

<p>Multiple '?' preceded tokens are treated all mixed together.  That
means '?A|B ?C|D' is equivalent to '?A|B|C|D'.  If you want to mean
'(A or B) and (C or D)', use AND syntax instead: 'A|B C|D'.</p>

<h4>
<a name="-e-pattern---andpattern" class="anchor" href="#-e-pattern---andpattern"><span class="octicon octicon-link"></span></a><strong>-e</strong> <em>pattern</em>, <strong>--and</strong>=<em>pattern</em>
</h4>

<p>Specify positive match token.  Next two commands are equivalent.</p>

<pre><code>greple 'foo bar baz'
greple -e foo -e bar -e baz
</code></pre>

<p>First character is not interpreted, so next commands will search the
pattern '-baz'.</p>

<pre><code>greple -e -baz
</code></pre>

<p>Space characters are treated specially by <strong>-e</strong> and <strong>-v</strong> options.
They are replaced by the pattern which matches any number of
white spaces including newline.  So the pattern can be expand to
multiple lines.  Next commands search the series of word 'foo', 'bar'
and 'baz' even if they are separated by newlines.</p>

<pre><code>greple -e 'foo bar baz'
</code></pre>

<h4>
<a name="-v-pattern---notpattern" class="anchor" href="#-v-pattern---notpattern"><span class="octicon octicon-link"></span></a><strong>-v</strong> <em>pattern</em>, <strong>--not</strong>=<em>pattern</em>
</h4>

<p>Specify negative match token.  Because it does not affect to the bare
pattern argument, you can narrow down the search result like this.</p>

<pre><code>greple foo pattern file
greple foo pattern file -v bar
greple foo pattern file -v bar -v baz
</code></pre>

<h4>
<a name="--repattern" class="anchor" href="#--repattern"><span class="octicon octicon-link"></span></a><strong>--re</strong>=<em>pattern</em>
</h4>

<p>Specify regular expression.  No special treatment for space and wide
characters.</p>

<h4>
<a name="--fepattern" class="anchor" href="#--fepattern"><span class="octicon octicon-link"></span></a><strong>--fe</strong>=<em>pattern</em>
</h4>

<p>Specify fixed string pattern, like fgrep.</p>

<h2>
<a name="grep-like-options" class="anchor" href="#grep-like-options"><span class="octicon octicon-link"></span></a><strong>GREP LIKE OPTIONS</strong>
</h2>

<h4>
<a name="-i" class="anchor" href="#-i"><span class="octicon octicon-link"></span></a><strong>-i</strong>
</h4>

<p>Ignore case.</p>

<h4>
<a name="-l" class="anchor" href="#-l"><span class="octicon octicon-link"></span></a><strong>-l</strong>
</h4>

<p>List filename only.</p>

<h4>
<a name="-c---count" class="anchor" href="#-c---count"><span class="octicon octicon-link"></span></a><strong>-c</strong>, <strong>--count</strong>
</h4>

<p>Print count of matched block.</p>

<h4>
<a name="-n" class="anchor" href="#-n"><span class="octicon octicon-link"></span></a><strong>-n</strong>
</h4>

<p>Show line number.</p>

<h4>
<a name="-h---no-filename" class="anchor" href="#-h---no-filename"><span class="octicon octicon-link"></span></a><strong>-h</strong>, <strong>--no-filename</strong>
</h4>

<p>Do not display filename.</p>

<h4>
<a name="-h" class="anchor" href="#-h"><span class="octicon octicon-link"></span></a><strong>-H</strong>
</h4>

<p>Display filename always.</p>

<h4>
<a name="-o" class="anchor" href="#-o"><span class="octicon octicon-link"></span></a><strong>-o</strong>
</h4>

<p>Print matched string only.</p>

<h4>
<a name="-an---after-contextn" class="anchor" href="#-an---after-contextn"><span class="octicon octicon-link"></span></a><strong>-A</strong>[<em>n</em>], <strong>--after-context</strong>[=<em>n</em>]</h4>

<h4>
<a name="-bn---before-contextn" class="anchor" href="#-bn---before-contextn"><span class="octicon octicon-link"></span></a><strong>-B</strong>[<em>n</em>], <strong>--before-context</strong>[=<em>n</em>]</h4>

<h4>
<a name="-cn---contextn" class="anchor" href="#-cn---contextn"><span class="octicon octicon-link"></span></a><strong>-C</strong>[<em>n</em>], <strong>--context</strong>[=<em>n</em>]</h4>

<p>Print <em>n</em>-blocks before/after matched string.  The value <em>n</em> can be
omitted and the default is 2.  When used with paragraph option <strong>-p</strong>,
<em>n</em> means number of paragraphs.</p>

<p>Actually, these options expand the area of logical operation.  It
means</p>

<pre><code>grep -C1 'foo bar baz'
</code></pre>

<p>matches following text.</p>

<pre><code>foo
bar
baz
</code></pre>

<p>Moreover</p>

<pre><code>greple -C1 'foo baz'
</code></pre>

<p>also matches this text, because matching blocks around 'foo' and 'bar'
overlaps each other and makes single block.</p>

<h4>
<a name="-f-file---filefile" class="anchor" href="#-f-file---filefile"><span class="octicon octicon-link"></span></a><strong>-f</strong> <em>file</em>, <strong>--file</strong>=<em>file</em>
</h4>

<p>Specify the file which contains search pattern.  When file contains
multiple lines, patterns on each lines are search in OR context.  The
line starting with sharp (#) character is ignored.</p>

<h4>
<a name="--nodecompress" class="anchor" href="#--nodecompress"><span class="octicon octicon-link"></span></a><strong>--</strong>[<strong>no</strong>]<strong>decompress</strong>
</h4>

<p>Switch for handling compressed files.  Default is true.</p>

<h4>
<a name="--colorautoalwaysnever---nocolor" class="anchor" href="#--colorautoalwaysnever---nocolor"><span class="octicon octicon-link"></span></a><strong>--color</strong>=<em>auto</em>|<em>always</em>|<em>never</em>, <strong>--nocolor</strong>
</h4>

<p>Use terminal color capability to emphasize the matched text.  Default
is 'auto': effective when STDOUT is a terminal and option <strong>-o</strong> is not
given, not otherwise.  Option value 'always' and 'never' will work as
expected.</p>

<p>Option <strong>--nocolor</strong> is alias for <strong>--color</strong>=<em>never</em>.</p>

<h4>
<a name="--colormodergbcymwrgbcymwubr---quotestartend" class="anchor" href="#--colormodergbcymwrgbcymwubr---quotestartend"><span class="octicon octicon-link"></span></a><strong>--colormode</strong>=<em>RGBCYMWrgbcymwUBR</em>, <strong>--quote</strong>=<em>start</em>,<em>end</em>
</h4>

<p>Specify color mode.  Use combination string from R(ed), G(reen),
B(lue), C(yan), M(agenta), Y(ellow), W(hite), U(nderline), (bol)D,
S(tandout).  Lowercase form of RGBCMYW means background color.
Default is RD: RED and BOLD.</p>

<p>If the mode string contains comma ',' character, they are used to
quote the matched string.  If you want to quote the pattern by angle
bracket, use like this.</p>

<pre><code>greple --quote='&lt;,&gt;' pattern
</code></pre>

<p>Option <strong>--quote</strong> is an alias for <strong>--colormode</strong>, but it set the
option <strong>--color</strong>=<em>always</em> at the same time.</p>

<p>Multiple colors can be specified separating by white spaces.  Those
colors will be applied for each pattern keywords.  Next command will
show word 'foo' in red, 'bar' in green and 'baz' in blue.</p>

<pre><code>greple --colormode='R G B' 'foo bar baz' ...
</code></pre>

<h4>
<a name="--colorful" class="anchor" href="#--colorful"><span class="octicon octicon-link"></span></a><strong>--colorful</strong>
</h4>

<p>Shortcut for <strong>--colormode</strong>='<em>RD GD BD CD MD YD</em>'</p>

<h2>
<a name="other-options" class="anchor" href="#other-options"><span class="octicon octicon-link"></span></a><strong>OTHER OPTIONS</strong>
</h2>

<h4>
<a name="-p---paragraph" class="anchor" href="#-p---paragraph"><span class="octicon octicon-link"></span></a><strong>-p</strong>, <strong>--paragraph</strong>
</h4>

<p>Print the paragraph which contains the pattern.  Each paragraph is
delimited by two or more successive newline characters by default.  Be
aware that an empty line is not paragraph delimiter if which contains
space characters.  Example:</p>

<pre><code>greple -np 'setuid script' /usr/man/catl/perl.l

greple -pe '^struct sockaddr' /usr/include/sys/socket.h
</code></pre>

<p>It changes the unit of context specified by <strong>-A</strong>, <strong>-B</strong>, <strong>-C</strong>
options.</p>

<h4>
<a name="--all" class="anchor" href="#--all"><span class="octicon octicon-link"></span></a><strong>--all</strong>
</h4>

<p>Treat entire file contents as a single block.  This is almost
identical to following command.</p>

<pre><code>greple --block='(?s).*'
</code></pre>

<h4>
<a name="--blockpattern---blocksub" class="anchor" href="#--blockpattern---blocksub"><span class="octicon octicon-link"></span></a><strong>--block</strong>=<em>pattern</em>, <strong>--block</strong>=<em>&amp;sub</em>
</h4>

<p>Specify the record block to display.  Default block is a single line.</p>

<p>Next is almost same as <strong>--paragraph</strong> option.</p>

<pre><code>greple --block='(.+\n)+'
</code></pre>

<p>Next command treat the data as a series of 10-line blocks.</p>

<pre><code>greple -n --block='(.*\n){1,10}'
</code></pre>

<p>When blocks are not continuous and there are gaps between them, the
match occurred outside blocks are ignored.</p>

<p>If multiple block options are supplied, overlapping blocks are merged
into single block.</p>

<p>Please be aware that this option is sometimes quite time consuming,
because it finds all blocks before processing.</p>

<h4>
<a name="--blockendstring" class="anchor" href="#--blockendstring"><span class="octicon octicon-link"></span></a><strong>--blockend</strong>=<em>string</em>
</h4>

<p>Change the end mark displayed after <strong>-pABC</strong> or <strong>--block</strong> options.
Default value is "--\n".</p>

<h4>
<a name="--insidepattern" class="anchor" href="#--insidepattern"><span class="octicon octicon-link"></span></a><strong>--inside</strong>=<em>pattern</em>
</h4>

<h4>
<a name="--outsidepattern" class="anchor" href="#--outsidepattern"><span class="octicon octicon-link"></span></a><strong>--outside</strong>=<em>pattern</em>
</h4>

<p>Option <strong>--inside</strong> and <strong>--outside</strong> limit the text area to be matched.
For simple example, if you want to find string 'and' not in the word
'command', it can be done like this.</p>

<pre><code>greple --outside=command and
</code></pre>

<p>The block can be larger and expand to multiple lines.  Next command
searches from C source, excluding comment part.</p>

<pre><code>greple --outside '(?s)/\*.*?\*/'
</code></pre>

<p>Next command searches only from POD part of the perl script.</p>

<pre><code>greple --inside='(?s)^=.*?(^=cut|\Z)'
</code></pre>

<p>When multiple <strong>inside</strong> and <strong>outside</strong> regions are specified, those
regions are mixed up in union way.</p>

<p>In multiple color environment, and if single keyword is specified,
matches in each <strong>--inside</strong>/<strong>outside</strong> regions are printed in
different colors.  Forcing this operation with multiple keywords, use
<strong>--regioncolor</strong> option.</p>

<h4>
<a name="--insidefunction" class="anchor" href="#--insidefunction"><span class="octicon octicon-link"></span></a><strong>--inside</strong>=<em>&amp;function</em>
</h4>

<h4>
<a name="--outsidefunction" class="anchor" href="#--outsidefunction"><span class="octicon octicon-link"></span></a><strong>--outside</strong>=<em>&amp;function</em>
</h4>

<p>If the pattern name begins by ampersand (&amp;) character, it is treated
as a name of subroutine which returns a list of blocks.  Using this
option, user can use arbitrary function to determine from what part of
the text they want to search.  User defined function can be defined in
<code>.greplerc</code> file or by module option.</p>

<h4>
<a name="--includepattern" class="anchor" href="#--includepattern"><span class="octicon octicon-link"></span></a><strong>--include</strong>=<em>pattern</em>
</h4>

<h4>
<a name="--excludepattern" class="anchor" href="#--excludepattern"><span class="octicon octicon-link"></span></a><strong>--exclude</strong>=<em>pattern</em>
</h4>

<h4>
<a name="--includefunction" class="anchor" href="#--includefunction"><span class="octicon octicon-link"></span></a><strong>--include</strong>=<em>&amp;function</em>
</h4>

<h4>
<a name="--excludefunction" class="anchor" href="#--excludefunction"><span class="octicon octicon-link"></span></a><strong>--exclude</strong>=<em>&amp;function</em>
</h4>

<p><strong>--include</strong>/<strong>exclude</strong> option behave exactly same as
<strong>--inside</strong>/<strong>outside</strong> when used alone.</p>

<p>When used in combination, <strong>--include</strong>/<strong>exclude</strong> are mixed in AND
manner, while <strong>--inside</strong>/<strong>outside</strong> are in OR.</p>

<p>Thus, in the next example, first line prints all matches, and second
does none.</p>

<pre><code>greple --inside PATTERN --outside PATTERN

greple --include PATTERN --exclude PATTERN
</code></pre>

<p>You can make up desired matches using <strong>--inside</strong>/<strong>outside</strong> option,
then remove unnecessary part by <strong>--include</strong>/<strong>exclude</strong></p>

<h4>
<a name="--strict" class="anchor" href="#--strict"><span class="octicon octicon-link"></span></a><strong>--strict</strong>
</h4>

<p>Limit the match area strictly.</p>

<p>By default, <strong>--block</strong>, <strong>--inside</strong>, <strong>--outside</strong> option allows
partial match within the specified area.  For instance,</p>

<pre><code>greple --inside and command
</code></pre>

<p>matches pattern <code>command</code> because the part of matched string is
included in specified inside-area.  Partial match failes when option
<strong>--strict</strong> provided, and longer string never matches within shorter
area.</p>

<h4>
<a name="--join" class="anchor" href="#--join"><span class="octicon octicon-link"></span></a><strong>--join</strong>
</h4>

<h4>
<a name="--joinbystring" class="anchor" href="#--joinbystring"><span class="octicon octicon-link"></span></a><strong>--joinby</strong>=<em>string</em>
</h4>

<p>Convert newline character found in matched string to empty or specifed
<em>string</em>.  Using <strong>--join</strong> with <strong>-o</strong> (only-matching) option, you can
collect searching sentence list in one per line form.  This is almost
useless for English text but sometimes useful for Japanese text.  For
example, next command prints the list of KATAKANA words.</p>

<pre><code>greple -ho --join '\p{utf8::InKatakana}[\n\p{utf8::InKatakana}]*'
</code></pre>

<h4>
<a name="--icodecode" class="anchor" href="#--icodecode"><span class="octicon octicon-link"></span></a><strong>--icode</strong>=<em>code</em>
</h4>

<p>Target file is assumed to be encoded in utf8 by default.  Use this
option to set specific encoding.  When handling Japanese text, you may
choose from 7bit-jis (jis), euc-jp or shiftjis (sjis).  Multiple code
can be supplied using multiple option or combined code names with
space or comma, then file encoding is guessed from those code sets.
Use encoding name 'guess' for automatic recognition from default code
list which is euc-jp and 7bit-jis.  Following commands are all
equivalent.</p>

<pre><code>greple --icode=guess ...
greple --icode=euc-jp,7bit-jis ...
greple --icode=euc-jp --icode=7bit-jis ...
</code></pre>

<p>Default code set are always included suspect code list.  If you have
just one code adding to suspect list, put + mark before the code name.
Next example does automatic code detection from euc-kr, ascii, utf8
and UTF-16/32.</p>

<pre><code>greple --icode=+euc-kr ...
</code></pre>

<h4>
<a name="--ocodecode" class="anchor" href="#--ocodecode"><span class="octicon octicon-link"></span></a><strong>--ocode</strong>=<em>code</em>
</h4>

<p>Specify output code.  Default is utf8.</p>

<h4>
<a name="--needn" class="anchor" href="#--needn"><span class="octicon octicon-link"></span></a><strong>--need</strong>=<em>n</em>
</h4>

<h4>
<a name="--allown" class="anchor" href="#--allown"><span class="octicon octicon-link"></span></a><strong>--allow</strong>=<em>n</em>
</h4>

<p>Option to compromize matching condition.  Option <strong>--need</strong> specifies
the required match count, and <strong>--allow</strong> the number of negative
condition to be overlooked.</p>

<pre><code>greple --need=2 --allow=1 'foo bar baz -yabba -dabba -doo'
</code></pre>

<p>Above command prints the line which contains two or more from 'foo',
'bar' and 'baz', and does not include more than one of 'yabba',
'dabba' or 'doo'.</p>

<p>Using option <strong>--need</strong>=<em>1</em>, <strong>greple</strong> produces same result as <strong>grep</strong>
command.</p>

<pre><code>grep -e foo -e bar -e baz
greple --need=1 -e foo -e bar -e baz
</code></pre>

<p>When the count <em>n</em> is negative value, it is subtracted from maximum
value.</p>

<h4>
<a name="--iffilter---ifexpfilterexpfilter" class="anchor" href="#--iffilter---ifexpfilterexpfilter"><span class="octicon octicon-link"></span></a><strong>--if</strong>=<em>filter</em>, <strong>--if</strong>=<em>EXP</em>:<em>filter</em>:<em>EXP</em>:<em>filter</em>:...</h4>

<p>You can specify filter command which is applied to each files before
search.  If only one filter command is specified, it is applied to all
files.  If filter information include multiple fields separated by
colons, first field will be perl expression to check the filename
saved in variable $_.  If it successes, next filter command is pushed.
These expression and command list can be repeated.</p>

<pre><code>greple --if=rev perg
greple --if='/\.tar$/:tar tvf -'
</code></pre>

<p>If the command doesn't accept standard input as processing data, you
may be able to use special device:</p>

<pre><code>greple --if='nm /dev/stdin' crypt /usr/lib/lib*
</code></pre>

<p>Filters for compressed and gzipped file is set by default unless
<strong>--nodecompress</strong> option is given.  Default action is like this:</p>

<pre><code>greple --if='s/\.Z$//:zcat:s/\.g?z$//:gunzip -c'
</code></pre>

<h4>
<a name="--offilter" class="anchor" href="#--offilter"><span class="octicon octicon-link"></span></a><strong>--of</strong>=<em>filter</em>
</h4>

<p>Specify output filter commands.</p>

<h4>
<a name="--requirefilename" class="anchor" href="#--requirefilename"><span class="octicon octicon-link"></span></a><strong>--require</strong>=<em>filename</em>
</h4>

<p>Include arbitrary perl program.</p>

<h4>
<a name="--pgp" class="anchor" href="#--pgp"><span class="octicon octicon-link"></span></a><strong>--pgp</strong>
</h4>

<p>Invoke PGP decrypt command for files end with .pgp, .gpg or .asc.  PGP
passphrase is asked only once at the beginning of command execution.</p>

<h4>
<a name="--pgppassphrase" class="anchor" href="#--pgppassphrase"><span class="octicon octicon-link"></span></a><strong>--pgppass</strong>=<em>phrase</em>
</h4>

<p>You can specify PGP passphrase by this option.  Generally, it is not
recommended to use.</p>

<h4>
<a name="--globpattern" class="anchor" href="#--globpattern"><span class="octicon octicon-link"></span></a><strong>--glob</strong>=<em>pattern</em>
</h4>

<p>Get files matches to specified pattern and use them as a target files.
Using <strong>--chdir</strong> and <strong>--glob</strong> makes easy to use <strong>greple</strong> for fixed
common job.</p>

<h4>
<a name="--chdirdirectory" class="anchor" href="#--chdirdirectory"><span class="octicon octicon-link"></span></a><strong>--chdir</strong>=<em>directory</em>
</h4>

<p>Change directory before processing files.  When multiple directories
are specified in <strong>--chdir</strong> option, by using wildcard form or
repeating option, <strong>--glob</strong> file expantion will be done for every
directories.</p>

<pre><code>greple --chdir '/usr/man/man?' --glob '*.[0-9]' ...
</code></pre>

<h4>
<a name="--printfunction---printsub" class="anchor" href="#--printfunction---printsub"><span class="octicon octicon-link"></span></a><strong>--print</strong>=<em>function</em>, <strong>--print</strong>=<em>sub{...}</em>
</h4>

<h4>
<a name="--continue" class="anchor" href="#--continue"><span class="octicon octicon-link"></span></a><strong>--continue</strong>
</h4>

<p>Specify user defined function executed before data print.  Text to be
printed is replaced by the result of the funcion.  Arbitrary function
can be defined in <code>.greplerc</code> file.  Matched data is placed in
variable <code>$_</code>.  Other information is passed by key-value pair in the
arguments.  Filename is passed by <code>file</code> key.  Matched informaiton is
passed by <code>matched</code> key, in the form of perl array reference:
<code>[[start,end],[start,end]...]</code>.</p>

<p>Simplest function is <strong>--print</strong>='<em>sub{$</em>}_'.  Coloring capability can
be used like this:</p>

<pre><code># ~/.greplerc
__CODE__
sub print_simple {
    my %attr = @_;
    for my $r (reverse @{$attr{matched}}) {
        my($s, $e) = @$r;
        substr($_, $s, $e - $s) = color(substr($_, $s, $e - $s));
    }
    $_;
}
</code></pre>

<p>Then, you can use this function in the command line.</p>

<pre><code>greple --print=print_simple ...
</code></pre>

<h4>
<a name="--readlist" class="anchor" href="#--readlist"><span class="octicon octicon-link"></span></a><strong>--readlist</strong>
</h4>

<p>Get filenames from standard input.  Read standard input and use each
line as a filename for searching.  You can feed the output from other
command like <a href="http://man.he.net/man1/find">find(1)</a> for <strong>greple</strong> with this option.  Next example
searches string from files modified within 7 days:</p>

<pre><code>find . -mtime -7 -print | greple --readlist pattern
</code></pre>

<h4>
<a name="--man" class="anchor" href="#--man"><span class="octicon octicon-link"></span></a><strong>--man</strong>
</h4>

<p>Show manual page.</p>

<h4>
<a name="--norc" class="anchor" href="#--norc"><span class="octicon octicon-link"></span></a><strong>--norc</strong>
</h4>

<p>Do not read startup file: <code>~/.greplerc</code>.</p>

<h4>
<a name="-d-flags" class="anchor" href="#-d-flags"><span class="octicon octicon-link"></span></a><strong>-d</strong> <em>flags</em>
</h4>

<p>Display informations.  Various kind of debug, diagnostic, monitor
information can be display by giving appropriate flag to -d option.</p>

<pre><code>f: processing file name
s: statistic information
m: misc debug information
o: option related information
p: run 'ps' command before termination (on Unix)
</code></pre>

<h1>
<a name="environment-and-startup-file" class="anchor" href="#environment-and-startup-file"><span class="octicon octicon-link"></span></a>ENVIRONMENT and STARTUP FILE</h1>

<p>Environment variable GREPLEOPTS is used as a default options.  They
are inserted before command line options.</p>

<p>Before starting execution, <em>greple</em> reads the file named <code>.greplerc</code>
on user's home directory.  Following directives can be used.</p>

<h4>
<a name="option-name-string" class="anchor" href="#option-name-string"><span class="octicon octicon-link"></span></a><strong>option</strong> <em>name</em> string</h4>

<p>Argument <em>name</em> of 'option' directive is user defined option name.
The rest are processed by <em>shellwords</em> routine defined in
Text::ParseWords module.  Be sure that this module sometimes requires
escape backslashes.</p>

<p>Any kind of string can be used for option name but it is not combined
with other options.</p>

<pre><code>option --fromcode --outside='(?s)\/\*.*?\*\/'
option --fromcomment --inside='(?s)\/\*.*?\*\/'
</code></pre>

<p>If the option named <strong>default</strong> is defined, it will be used as a
default option.</p>

<h4>
<a name="help-name" class="anchor" href="#help-name"><span class="octicon octicon-link"></span></a><strong>help</strong> <em>name</em>
</h4>

<p>If 'help' directive is used for same option name, it will be printed
in usage message.  If the help message is 'ignore', corresponding line
won't show up in the usage.</p>

<h4>
<a name="define-name-string" class="anchor" href="#define-name-string"><span class="octicon octicon-link"></span></a><strong>define</strong> <em>name</em> string</h4>

<p>Directive 'define' is almost same as 'option', but argument is not
processed by <em>shellwords</em> and treated just a simple text.
Metacharacters can be included without escaping.  Defined string
replacement is done only in definition in option argument.  If you
want to use the word in command line, use option directive instead.</p>

<pre><code>define :kana: \p{utf8::InKatakana}
option --kanalist --color=never -o --join --re ':kana:[:kana:\n]+'
help   --kanalist List up Katakana string
</code></pre>

<p>When <em>greple</em> found <code>__CODE__</code> line in <code>.greplerc</code> file, the rest
of the file is evaluated as a Perl program.  You can define your own
subroutines which can be used by <strong>--inside</strong> and <strong>--outside</strong> options.
For those subroutines, file content will be provided by global
variable <code>$_</code>.  Expected response from the subroutine is the list of
array references, which is made up by start and end offset pairs.</p>

<p>For example, suppose that the following function is defined in your
<code>.greplerc</code> file.</p>

<pre><code>__CODE__
sub odd_line {
    my @list;
    my $i;
    while (/.*\n/g) {
        push(@list, [ $-[0], $+[0] ]) if ++$i % 2;
    }
    @list;
}
</code></pre>

<p>You can use next command to search pattern included in odd number
lines.</p>

<pre><code>% greple --inside '&amp;odd_line' patten files...
</code></pre>

<h1>
<a name="module" class="anchor" href="#module"><span class="octicon octicon-link"></span></a>MODULE</h1>

<p>Modules can be specified only at the beginning of command line by
<strong>-M</strong>_module_ option.  Name <em>module</em> is prepended by <strong>App::Greple</strong>,
so place the module file in <code>App/Greple/</code> directory in Perl library.</p>

<p>If the package name is declared properly, <code>__DATA__</code> section in the
module file will be interpreted same as <code>.greplerc</code> file content.</p>

<p>See this sample module code.  This sample define options to search
from pod, comment and other segment in Perl script.  Those capability
can be implemented both in function and macro.</p>

<pre><code>package App::Greple::perl;


BEGIN {
    use Exporter   ();
    our ($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS);


    $VERSION = sprintf "%d.%03d", q$Revision: 6.14 $ =~ /(\d+)/g;


    @ISA         = qw(Exporter);
    @EXPORT      = qw(&amp;pod &amp;comment &amp;podcomment);
    %EXPORT_TAGS = ( );
    @EXPORT_OK   = qw();
}
our @EXPORT_OK;


END { }


my $pod_re = qr{^=\w+(?s:.*?)(?:\Z|^=cut\s*\n)}m;
my $comment_re = qr{^(?:[ \t]*#.*\n)+}m;


sub pod {
    my @list;
    while (/$pod_re/g) {
        push(@list, [ $-[0], $+[0] ] );
    }
    @list;
}
sub comment {
    my @list;
    while (/$comment_re/g) {
        push(@list, [ $-[0], $+[0] ] );
    }
    @list;
}
sub podcomment {
    my @list;
    while (/$pod_re|$comment_re/g) {
        push(@list, [ $-[0], $+[0] ] );
    }
    @list;
}


1;


__DATA__


define :comment: ^(\s*#.*\n)+
define :pod: ^=(?s:.*?)(?:\Z|^=cut\s*\n)


#option --pod --inside :pod:
#option --comment --inside :comment:
#option --code --outside :pod:|:comment:


option --pod --inside '&amp;pod'
option --comment --inside '&amp;comment'
option --code --outside '&amp;podcomment'
</code></pre>

<p>You can use the module like this:</p>

<pre><code>greple -Mperl --pod ...

greple -Mperl --code --comment --pod ...
</code></pre>

<h1>
<a name="history" class="anchor" href="#history"><span class="octicon octicon-link"></span></a>HISTORY</h1>

<p>Most capability of <strong>greple</strong> is derived from <strong>mg</strong> command, which has
been developing from early 1990's by the same author.  Because modern
standard <strong>grep</strong> family command becomes to have similar capabilities,
it is a time to clean up entire functionarities, totally remodel the
option interfaces, and change the command name. (2013.11)</p>

<h1>
<a name="author" class="anchor" href="#author"><span class="octicon octicon-link"></span></a>AUTHOR</h1>

<p>Kazumasa Utashiro</p>

<h1>
<a name="see-also" class="anchor" href="#see-also"><span class="octicon octicon-link"></span></a>SEE ALSO</h1>

<p><a href="http://man.he.net/man1/grep">grep(1)</a>, <a href="http://man.he.net/man1/perl">perl(1)</a></p>

<p><a href="http://kaz-utashiro.github.io/greple/">github</a></p>

<h1>
<a name="license" class="anchor" href="#license"><span class="octicon octicon-link"></span></a>LICENSE</h1>

<p>Copyright (c) 1991-2013 Kazumasa Utashiro</p>

<p>Use and redistribution for ANY PURPOSE are granted as long as all
copyright notices are retained.  Redistribution with modification is
allowed provided that you make your modified version obviously
distinguishable from the original one.  THIS SOFTWARE IS PROVIDED BY
THE AUTHOR ''AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES ARE
DISCLAIMED.</p>
      </section>
      <footer>
        <p><small>Hosted on <a href="http://pages.github.com">GitHub Pages</a> using the Dinky theme</small></p>
      </footer>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
		
  </body>
</html>
